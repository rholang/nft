!function(r,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((r="undefined"!=typeof globalThis?globalThis:r||self)["@rholang/sdk"]={})}(this,(function(r){"use strict";r.checkBalance=({account:r})=>` new  rl(\`rho:registry:lookup\`),return, RevVaultCh, vaultCh in {\r\n      rl!(\`rho:rchain:revVault\`, *RevVaultCh) |\r\n      for (@(_, RevVault) <- RevVaultCh) {\r\n        @RevVault!("findOrCreate", "${r}", *vaultCh) |\r\n        for (@maybeVault <- vaultCh) {\r\n          match maybeVault {\r\n            (true, vault) => @vault!("balance", *return)\r\n            (false, err)  => return!(err)\r\n          }\r\n        }\r\n      }\r\n    }`,r.compose=({})=>'new compose, entryCh, entryUriCh, insertArbitrary(`rho:registry:insertArbitrary`), stdout(`rho:rchain:deployId`) in {\r\n  contract compose(input ...@sends) = {\r\n    for(...@inp <= input) {\r\n      new apply in {\r\n        apply!(inp, sends) |\r\n        contract apply(argsc, @[send ...rest]) = {\r\n          match rest {\r\n            [] => {\r\n              // the last contract is the end of composition and it\'s called with suplied args\r\n              // and args returned from previous contract (without return channel)\r\n              match send { [s ...args] => @s!(args ++ *argsc) }\r\n            }\r\n            _ => {\r\n              new ret in {\r\n                // each contract is called with arguments combined from: suplied args,\r\n                // args returned from previous contract and a new return channel\r\n                match send { [s ...args] => @s!(args ++ *argsc ++ [*ret]) } |\r\n                // match send { {@s!(...args)} => @s!(...args ...*argsc, *ret) } |\r\n                for(...@inp\' <- ret) { apply!(inp\', rest) }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  } |\r\n\r\n  new name, location, hash, print in {\r\n    contract name     (@[a,    ret]) = { @ret!("Name: " ++ a) } |\r\n    contract location (@[a, b, ret]) = { @ret!([a, b]) } |\r\n    contract hash     (@[a, b, ret]) = { @ret!({"Hash": a, "Data": b}) } |\r\n    contract print    (@[a        ]) = { stdout!(a) } |\r\n\r\n      new nameLocHash in {\r\n      // - version with compose without creating intermediate channels\r\n      // nameLocHash contract is a composition (sequence in this case)\r\n      // of name, location, hash and print contracts\r\n      compose!(\r\n        *nameLocHash,\r\n        [*name],\r\n        [*location, 666],\r\n        [*hash, "SHA256"],\r\n       \r\n      ) |\r\n      nameLocHash!("Rick") |\r\n      nameLocHash!("Morty")\r\n    }\r\n  } |\r\n\r\n  insertArbitrary!(bundle+{*entryCh}, *entryUriCh) |\r\n\r\n  for (entryUri <- entryUriCh) {\r\n      stdout!({"uri": *entryUri})\r\n  }\r\n} \r\n\r\n',r.factory=({n:r,version:e,depthcontract:n})=>`new \r\n  basket,\r\n\r\n  entryCh,\r\n  entryUriCh,\r\n\r\n  byteArraySafeToStoreCh,\r\n  iterateOnThmKeysCh,\r\n  createPursesCh,\r\n  makePurseCh,\r\n  calculateFeeCh,\r\n  pursesTreeHashMapCh,\r\n  pursesForSaleTreeHashMapCh,\r\n  initializeOCAPOnBoxCh,\r\n\r\n    // dont use multi line /* */ -> error\r\n    // 'vault is the ultimate accessibility unforgeable in\r\n    // master contract, every data is stored in channels that\r\n    // derives from *vault unforgeable name\r\n\r\n    // // tree hash map of purses :\r\n    // thm <- @(*vault, "purses", "contract03")\r\n\r\n    // // tree hash map of purses data :\r\n    // thm <- @(*vault, "pursesData", "contract03")\r\n\r\n    // // contract's configs\r\n    // config <- @(*vault, "contractConfig", "contract03")\r\n\r\n    // // boxes\r\n    // box <- @(*vault, "boxes", "box01")\r\n    \r\n    // // box's configs\r\n    // config <- @(*vault, "boxConfig", "box01")\r\n\r\n    // // super keys of a given box\r\n    // superKeys <- @(*vault, "boxesSuperKeys", "box01")'\r\n\r\n  vault,\r\n\r\n  \r\n    // boxesThm and contractsThm only store the list\r\n    // of existing contracts / boxes, ex:\r\n    // boxesThm:\r\n    // { "box1": "exists", "mycoolbox": "exists" }\r\n\r\n    // Then each box is a Map stored at a unique channel\r\n    // (see above) and has the following structure:\r\n    // {\r\n    //   [contractId: string]: Set(purseId: string)\r\n    // }\r\n\r\n    // Each contract has its own tree hash map, and\r\n    // have the following structure:\r\n    // pursesThm:\r\n    // {\r\n    //   "1": { quantity: 2, type: "0", box: "box1", price: Nil},\r\n    //   "2": { quantity: 12, type: "0", box: "box1", price: 2},\r\n    // }\r\n  \r\n  boxesReadyCh,\r\n  contractsReadyCh,\r\n\r\n  TreeHashMap,\r\n\r\n  savePurseInBoxCh,\r\n  removePurseInBoxCh,\r\n  getBoxCh,\r\n  getPurseCh,\r\n  getContractPursesThmCh,\r\n  getContractPursesDataThmCh,\r\n\r\n  insertArbitrary(\`rho:registry:insertArbitrary\`),\r\n  revAddress(\`rho:rev:address\`),\r\n  registryLookup(\`rho:registry:lookup\`),\r\n  stdout(\`rho:rchain:deployId\`)\r\n\r\nin {\r\n\r\n  for (@boxesThm <- boxesReadyCh; @contractsThm <- contractsReadyCh) {\r\n\r\n    // returns the box if exists\r\n    for (@(boxId, return) <= getBoxCh) {\r\n      new ch1 in {\r\n        TreeHashMap!("get", boxesThm, boxId, *ch1) |\r\n        for (@exists <- ch1) {\r\n          if (exists == "exists") {\r\n            for (@box <<- @(*vault, "boxes", boxId)) {\r\n              @return!(box)\r\n            }\r\n          } else {\r\n            @return!(Nil)\r\n          }\r\n        }\r\n      }\r\n    } |\r\n\r\n    // returns the purse if exists AND is associated with box\r\n    for (@(box, contractId, purseId, return) <= getPurseCh) {\r\n      new ch1 in {\r\n        if (box.get(contractId) == Nil) {\r\n          @return!(Nil)\r\n        } else {\r\n          if (box.get(contractId).contains(purseId) == true) {\r\n            getContractPursesThmCh!((contractId, *ch1)) |\r\n            for (@pursesThm <- ch1) {\r\n              TreeHashMap!("get", pursesThm, purseId, return)\r\n            }\r\n          } else {\r\n            @return!(Nil)\r\n          }\r\n        }\r\n      }\r\n    } |\r\n\r\n    // returns the tree hash map of the contract's purses if exists\r\n    for (@(contractId, return) <= getContractPursesThmCh) {\r\n      new ch1 in {\r\n        TreeHashMap!("get", contractsThm, contractId, *ch1) |\r\n        for (@exists <- ch1) {\r\n          if (exists == "exists") {\r\n            for (@pursesThm <<- @(*vault, "purses", contractId)) {\r\n              @return!(pursesThm)\r\n            }\r\n          } else {\r\n            @return!(Nil)\r\n          }\r\n        }\r\n      }\r\n    } |\r\n\r\n    // returns the tree hash map of the contract's purses data if exists\r\n    for (@(contractId, return) <= getContractPursesDataThmCh) {\r\n      new ch1 in {\r\n        TreeHashMap!("get", contractsThm, contractId, *ch1) |\r\n        for (@exists <- ch1) {\r\n          if (exists == "exists") {\r\n            for (@pursesDataThm <<- @(*vault, "pursesData", contractId)) {\r\n              @return!(pursesDataThm)\r\n            }\r\n          } else {\r\n            @return!(Nil)\r\n          }\r\n        }\r\n      }\r\n    } |\r\n  \r\n    // remove purse in box, if found\r\n    for (@(boxId, contractId, purseId, return) <= removePurseInBoxCh) {\r\n      new ch1 in {\r\n        getBoxCh!((boxId, *ch1)) |\r\n        for (@box <- ch1) {\r\n          if (box == Nil) {\r\n            @return!("error: CRITICAL box not found")\r\n          } else {\r\n            if (box.get(contractId) == Nil) {\r\n              @return!("error: CRITICAL purse not found")\r\n            } else {\r\n              if (box.get(contractId).contains(purseId) == false) {\r\n                @return!("error: CRITICAL purse not found")\r\n              } else {\r\n                for (_ <- @(*vault, "boxes", boxId)) {\r\n                  stdout!(contractId ++ "/" ++ boxId ++ " purse " ++ purseId ++ " removed from box") |\r\n                  @(*vault, "boxes", boxId)!(box.set(contractId, box.get(contractId).delete(purseId))) |\r\n                  @return!((true, Nil))\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } |\r\n\r\n    // save purse id in box\r\n    for (@(contractId, boxId, purseId, merge, return) <= savePurseInBoxCh) {\r\n      new ch1, ch2, ch3, iterateAndMergePursesCh in {\r\n\r\n        getBoxCh!((boxId, *ch1)) |\r\n        getContractPursesThmCh!((contractId, *ch2)) |\r\n\r\n        for (@box <- ch1; @pursesThm <- ch2) {\r\n          match (box != Nil, pursesThm != Nil) {\r\n            (true, true) => {\r\n              if (box.get(contractId) == Nil) {\r\n                for (_ <- @(*vault, "boxes", boxId)) {\r\n                  stdout!(contractId ++ "/" ++ boxId ++ " purse " ++ purseId ++ " saved to box") |\r\n                  @(*vault, "boxes", boxId)!(box.set(contractId, Set(purseId))) |\r\n                  @return!((true, Nil))\r\n                }\r\n              } else {\r\n                if (box.get(contractId).contains(purseId) == false) {\r\n                  for (@contractConfig <<- @(*vault, "contractConfig", contractId)) {\r\n                    match (contractConfig.get("fungible") == true, merge) {\r\n                      (true, true) => {\r\n                        for (@pursesThm <<- @(*vault, "purses", contractId)) {\r\n                          TreeHashMap!("get", pursesThm, purseId, *ch3) |\r\n                          for (@purse <- ch3) {\r\n                            iterateAndMergePursesCh!((box, purse, pursesThm))\r\n                          }\r\n                        }\r\n                      }\r\n                      _ => {\r\n                        for (_ <- @(*vault, "boxes", boxId)) {\r\n                          stdout!(contractId ++ "/" ++ boxId ++ " purse " ++ purseId ++ " saved to box") |\r\n                          @(*vault, "boxes", boxId)!(box.set(\r\n                            contractId,\r\n                            box.get(contractId).union(Set(purseId))\r\n                          )) |\r\n                          @return!((true, Nil))\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n                } else {\r\n                  @return!("error: CRITICAL, purse already exists in box")\r\n                }\r\n              }\r\n            }\r\n          }\r\n        } |\r\n        // if contract is fungible, we may find a\r\n        // purse with same .price and .type property\r\n        // if found, then merge and delete current purse\r\n        for (@(box, purse, pursesThm) <- iterateAndMergePursesCh) {\r\n          new tmpCh, itCh in {\r\n            for (ids <= itCh) {\r\n              match *ids {\r\n                Set() => {\r\n                  stdout!(contractId ++ "/" ++ boxId ++ " purse " ++ purse.get("id") ++ " saved to box") |\r\n                  for (_ <- @(*vault, "boxes", boxId)) {\r\n                     @(*vault, "boxes", boxId)!(box.set(contractId, Set(purseId))) |\r\n                     @return!((true, Nil))\r\n                  }\r\n                }\r\n                Set(last) => {\r\n                  new ch4, ch5, ch6, ch7 in {\r\n                    TreeHashMap!("get", pursesThm, last, *ch4) |\r\n                    for (@purse2 <- ch4) {\r\n                      match (purse2.get("type") == purse.get("type"), purse2.get("price") == purse.get("price")) {\r\n                        (true, true) => {\r\n                          TreeHashMap!(\r\n                            "set",\r\n                            pursesThm,\r\n                            last,\r\n                            purse2.set("quantity", purse2.get("quantity") + purse.get("quantity")),\r\n                            *ch5\r\n                          ) |\r\n                          TreeHashMap!(\r\n                            "set",\r\n                            pursesThm,\r\n                            purse.get("id"),\r\n                            Nil,\r\n                            *ch6\r\n                          ) |\r\n                          for (@pursesDataThm <<- @(*vault, "pursesData", contractId)) {\r\n                            TreeHashMap!(\r\n                              "set",\r\n                              pursesDataThm,\r\n                              purse.get("id"),\r\n                              Nil,\r\n                              *ch7\r\n                            )\r\n                          } |\r\n                          for (_ <- ch5; _ <- ch6; _ <- ch7) {\r\n                            stdout!(contractId ++ "/" ++ boxId ++ " purse " ++ purse.get("id") ++ " merged into purse " ++ purse2.get("id")) |\r\n                            @return!((true, Nil))\r\n                          }\r\n                        }\r\n                        _ => {\r\n                          stdout!(contractId ++ "/" ++ boxId ++ " purse " ++ purse.get("id") ++ " saved to box") |\r\n                          for (_ <- @(*vault, "boxes", boxId)) {\r\n                            @(*vault, "boxes", boxId)!(box.set(\r\n                              contractId,\r\n                              box.get(contractId).union(Set(purse.get("id")))\r\n                            )) |\r\n                            @return!((true, Nil))\r\n                          }\r\n                        }\r\n                      }\r\n                    }\r\n\r\n                  }\r\n                }\r\n                Set(first ... rest) => {\r\n                  new ch4, ch5, ch6, ch7 in {\r\n                    TreeHashMap!("get", pursesThm, first, *ch4) |\r\n                    for (@purse2 <- ch4) {\r\n                      match (purse2.get("type") == purse.get("type"), purse2.get("price") == purse.get("price")) {\r\n                        (true, true) => {\r\n                          TreeHashMap!(\r\n                            "set",\r\n                            pursesThm,\r\n                            first,\r\n                            purse2.set("quantity", purse2.get("quantity") + purse.get("quantity")),\r\n                            *ch5\r\n                          ) |\r\n                          TreeHashMap!(\r\n                            "set",\r\n                            pursesThm,\r\n                            purse.get("id"),\r\n                            Nil,\r\n                            *ch6\r\n                          ) |\r\n                          for (@pursesDataThm <<- @(*vault, "pursesData", contractId)) {\r\n                            TreeHashMap!(\r\n                              "set",\r\n                              pursesDataThm,\r\n                              purse.get("id"),\r\n                              Nil,\r\n                              *ch7\r\n                            )\r\n                          } |\r\n                          for (_ <- ch5; _ <- ch6; _ <- ch7) {\r\n                            stdout!(contractId ++ "/" ++ boxId ++ " purse " ++ purse.get("id") ++ " merged into purse " ++ purse2.get("id")) |\r\n                            @return!((true, Nil))\r\n                          }\r\n                        }\r\n                        _ => {\r\n                          itCh!(rest)\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            } |\r\n            itCh!(box.get(contractId))\r\n          }\r\n        }\r\n      }\r\n    } |\r\n\r\n    \r\n    // makePurseCh\r\n    // only place where new purses are created:\r\n    // PURCHASE, WITHDRAW, and CREATE_PURSES may call this channel\r\n\r\n    // depending on if .fungible is true or false, it decides\r\n    // which id to give to the new purse, then it creates the\r\n    // purse and saves to box\r\n    \r\n    for (@(contractId, properties, data, merge, return) <= makePurseCh) {\r\n      new ch1, ch2, ch3, ch4, idAndQuantityCh in {\r\n        for (@contractConfig <<- @(*vault, "contractConfig", contractId)) {\r\n          if (contractConfig.get("fungible") == true) {\r\n            for (_ <- @(*vault, "contractConfig", contractId)) {\r\n              @(*vault, "contractConfig", contractId)!(contractConfig.set("counter", contractConfig.get("counter") + 1))\r\n            } |\r\n            idAndQuantityCh!({ "id": "${r}" %% { "n": contractConfig.get("counter") }, "quantity": properties.get("quantity") })\r\n          } else {\r\n            for (@pursesThm <<- @(*vault, "purses", contractId)) {\r\n              TreeHashMap!("get", pursesThm, properties.get("id"), *ch1) |\r\n              for (@existingPurse <- ch1) {\r\n\r\n                // check that nft does not exist\r\n                if (existingPurse == Nil) {\r\n                  if (properties.get("id") == "0") {\r\n                    idAndQuantityCh!({ "id": properties.get("id"), "quantity": properties.get("quantity") })\r\n                  } else {\r\n                    idAndQuantityCh!({ "id": properties.get("id"), "quantity": 1 })\r\n                  }\r\n                } else {\r\n\r\n                  // nft with id: "0" is a special nft from which\r\n                  // anyone can mint a nft that does not exist yet\r\n                  // used by dappy name system for example\r\n                  if (properties.get("id") == "0") {\r\n                    TreeHashMap!("get", pursesThm, properties.get("newId"), *ch2) |\r\n                    for (@purseWithNewId <- ch2) {\r\n                      match (properties.get("newId"), purseWithNewId) {\r\n                        (String, Nil) => {\r\n                          idAndQuantityCh!({ "id": properties.get("newId"), "quantity": 1 })\r\n                        }\r\n                        _ => {\r\n                          @return!("error: no .newId in payload or .newId already exists")\r\n                        }\r\n                      }\r\n                    }\r\n                  } else {\r\n                    @return!("error: purse id already exists")\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        } |\r\n        for (@idAndQuantity <- idAndQuantityCh) {\r\n          match properties\r\n            .set("id", idAndQuantity.get("id"))\r\n            .set("quantity", idAndQuantity.get("quantity"))\r\n            .delete("newId")\r\n          {\r\n            purse => {\r\n              match (purse, purse.get("id").length() > 0, purse.get("id").length() < 25) {\r\n                ({\r\n                  "quantity": Int,\r\n                  "type": String,\r\n                  "boxId": String,\r\n                  "id": String,\r\n                  "price": Nil \\/ Int\r\n                }, true, true) => {\r\n                  for (@pursesDataThm <<- @(*vault, "pursesData", contractId)) {\r\n                    for (@pursesThm <<- @(*vault, "purses", contractId)) {\r\n                      TreeHashMap!("set", pursesThm, purse.get("id"), purse, *ch3) |\r\n                      TreeHashMap!("set", pursesDataThm, purse.get("id"), data, *ch4)\r\n                    }\r\n                  } |\r\n\r\n                  for (_ <- ch3; _ <- ch4) {\r\n                    savePurseInBoxCh!((contractId, purse.get("boxId"), purse.get("id"), merge, return))\r\n                  }\r\n                }\r\n                _ => {\r\n                  @return!("error: invalid purse, one of the following errors: id length must be between length 1 and 24")\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } |\r\n\r\n    for (@(payload, contractId, return) <= createPursesCh) {\r\n      new itCh, sizeCh, createdPursesesCh, saveKeyAndBagCh in {\r\n        createdPursesesCh!([]) |\r\n        sizeCh!(payload.get("purses").keys().size()) |\r\n        for (@size <- sizeCh) {\r\n          itCh!(payload.get("purses").keys()) |\r\n          for(@set <= itCh) {\r\n            match set {\r\n              Nil => {}\r\n              Set(last) => {\r\n                new ch1, ch2 in {\r\n                  match payload.get("purses").get(last) {\r\n                    {\r\n                      "quantity": Int,\r\n                      "type": String,\r\n                      "id": String,\r\n                      "price": Nil \\/ Int,\r\n                      "boxId": String\r\n                    } => {\r\n                      getBoxCh!((payload.get("purses").get(last).get("boxId"), *ch1)) |\r\n                      for (@box <- ch1) {\r\n                        if (box == Nil) {\r\n                          @return!("error: some purses may have been created until one failed: box not found " ++ payload.get("purses").get(last).get("boxId"))\r\n                        } else {\r\n                          makePurseCh!((\r\n                            contractId,\r\n                            payload.get("purses").get(last),\r\n                            payload.get("data").get(last),\r\n                            true,\r\n                            *ch2\r\n                          )) |\r\n                          for (@r <- ch2) {\r\n                            match r {\r\n                              String => {\r\n                                @return!("error: some purses may have been created until one failed " ++ r)\r\n                              }\r\n                              _ => {\r\n                                @return!((true, Nil))\r\n                              }\r\n                            }\r\n                          }\r\n                        }\r\n                      }\r\n                    }\r\n                    _ => {\r\n                      @return!("error: invalid purse payload, some purses may have been successfuly created")\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n              Set(first ... rest) => {\r\n                new ch1, ch2 in {\r\n                  match payload.get("purses").get(first) {\r\n                    {\r\n                      "quantity": Int,\r\n                      "type": String,\r\n                      "id": String,\r\n                      "price": Nil \\/ Int,\r\n                      "boxId": String\r\n                    } => {\r\n                      getBoxCh!((payload.get("purses").get(first).get("boxId"), *ch1)) |\r\n                      for (@box <- ch1) {\r\n                        if (box == Nil) {\r\n                          @return!("error: some purses may have been created until one failed: box not found " ++ payload.get("purses").get(first).get("boxId"))\r\n                        } else {\r\n                          makePurseCh!((\r\n                            contractId,\r\n                            payload.get("purses").get(first),\r\n                            payload.get("data").get(first),\r\n                            true,\r\n                            *ch2\r\n                          )) |\r\n                          for (@r <- ch2) {\r\n                            match r {\r\n                              String => {\r\n                                @return!("error: some purses may have been created until one failed " ++ r)\r\n                              }\r\n                              _ => {\r\n                                itCh!(rest)\r\n                              }\r\n                            }\r\n                          }\r\n                        }\r\n                      }\r\n                    }\r\n                    _ => {\r\n                      @return!("error: invalid purse payload, some purses may have been successfuly created")\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } |\r\n\r\n    contract iterateOnThmKeysCh(@(ids, thm, return)) = {\r\n      new tmpCh, itCh in {\r\n        for (@(tmpCh, ids) <= itCh) {\r\n          for (tmp <- @tmpCh) {\r\n            match ids {\r\n              Nil => {\r\n                @return!(*tmp)\r\n              }\r\n              Set(last) => {\r\n                new ch1 in {\r\n                  TreeHashMap!("get", thm, last, *ch1) |\r\n                  for (@p <- ch1) {\r\n                    @return!(*tmp.set(last, p))\r\n                  }\r\n                }\r\n              }\r\n              Set(first ... rest) => {\r\n                new ch1 in {\r\n                  TreeHashMap!("get", thm, first, *ch1) |\r\n                  for (@p <- ch1) {\r\n                    @tmpCh!(*tmp.set(first, p)) |\r\n                    itCh!((tmpCh, rest))\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        } |\r\n        tmpCh!({}) |\r\n        itCh!((*tmpCh, ids))\r\n      }\r\n    } |\r\n\r\n    /* ################################################################################## */\r\n    /*                                Public interfaces                                   */\r\n\r\n    for (@("PUBLIC_READ_ALL_PURSES", contractId, return) <= entryCh) {\r\n      new ch1 in {\r\n        getContractPursesThmCh!((contractId, *ch1)) |\r\n        for (@pursesThm <- ch1) {\r\n          if (pursesThm == Nil) {\r\n            @return!("error: contract not found")\r\n          } else {\r\n            TreeHashMap!("getAllValues", pursesThm, return)\r\n          }\r\n        }\r\n      }\r\n    } |\r\n\r\n    for (@("PUBLIC_READ_BOX", boxId, return) <= entryCh) {\r\n      new ch1 in {\r\n        getBoxCh!((boxId, *ch1)) |\r\n        for (@box <- ch1) {\r\n          if (box == Nil) {\r\n            @return!("error: box not found")\r\n          } else {\r\n            for (@superKeys <<- @(*vault, "boxesSuperKeys", boxId)) {\r\n              for (@config <<- @(*vault, "boxConfig", boxId)) {\r\n                @return!(config.union({ "superKeys": superKeys, "purses": box, "version": "${e}" }))\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } |\r\n\r\n    for (@("PUBLIC_READ_PURSES", payload, return) <= entryCh) {\r\n      new ch1 in {\r\n        getContractPursesThmCh!((payload.get("contractId"), *ch1)) |\r\n        for (@pursesThm <- ch1) {\r\n          if (pursesThm == Nil) {\r\n            @return!("error: contract not found")\r\n          } else {\r\n            match payload.get("purseIds").size() < 101 {\r\n              true => {\r\n                iterateOnThmKeysCh!((payload.get("purseIds"), pursesThm, return))\r\n              }\r\n              _ => {\r\n                @return!("error: payload.purseIds must be a Set of strings with max size 100")\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } |\r\n\r\n    for (@("PUBLIC_READ_PURSES_DATA", payload, return) <= entryCh) {\r\n      new ch1 in {\r\n        getContractPursesDataThmCh!((payload.get("contractId"), *ch1)) |\r\n        for (@pursesDataThm <- ch1) {\r\n          if (pursesDataThm == Nil) {\r\n            @return!("error: contract not found")\r\n          } else {\r\n            match payload.get("purseIds").size() < 101 {\r\n              true => {\r\n                iterateOnThmKeysCh!((payload.get("purseIds"), pursesDataThm, return))\r\n              }\r\n              _ => {\r\n                @return!("error: payload.purseIds must be a Set of strings with max size 100")\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } |\r\n\r\n    for (@("PUBLIC_READ_CONFIG", contractId, return) <= entryCh) {\r\n      for (@config <<- @(*vault, "contractConfig", contractId)) {\r\n        @return!(config)\r\n      }\r\n    } |\r\n\r\n    for (@("PUBLIC_REGISTER_BOX", payload, return) <= entryCh) {\r\n      match (payload.get("boxId"), payload.get("publicKey"), payload.get("boxId").length() > 1, payload.get("boxId").length() < 25) {\r\n        (String, String, true, true) => {\r\n          new ch1, ch2, ch3, ch4, ch5, ch6 in {\r\n            registryLookup!(\`rho:rchain:revVault\`, *ch3) |\r\n            for (@(_, RevVault) <- ch3) {\r\n              revAddress!("fromPublicKey", payload.get("publicKey").hexToBytes(), *ch4) |\r\n              for (@a <- ch4) {\r\n                @RevVault!("findOrCreate", a, *ch5) |\r\n                for (@b <- ch5) {\r\n                  match b {\r\n                    (true, vaultFromPublicKey) => {\r\n                      ch6!(true)\r\n                    }\r\n                    _ => {\r\n                      @return!("error: invalid public key, could not get vault")\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            } |\r\n\r\n            TreeHashMap!("get", boxesThm, payload.get("boxId"), *ch1) |\r\n            for (@existingBox <- ch1; _ <- ch6) {\r\n              if (existingBox == Nil) {\r\n                new boxCh in {\r\n                  TreeHashMap!("set", boxesThm, payload.get("boxId"), "exists", *ch2) |\r\n                  for (_ <- ch2) {\r\n                    @(*vault, "boxes", payload.get("boxId"))!({}) |\r\n                    @(*vault, "boxesSuperKeys", payload.get("boxId"))!(Set()) |\r\n                    @(*vault, "boxConfig", payload.get("boxId"))!({ "publicKey": payload.get("publicKey") }) |\r\n                    @return!((true, bundle+{*boxCh})) |\r\n                    initializeOCAPOnBoxCh!((*boxCh, payload.get("boxId")))\r\n                  }\r\n                }\r\n              } else {\r\n                @return!("error: box already exists")\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } |\r\n\r\n    for (@(boxCh, boxId) <= initializeOCAPOnBoxCh) {\r\n\r\n      for (@("PUBLIC_REGISTER_CONTRACT", payload, return) <= @boxCh) {\r\n        match payload {\r\n          { "contractId": String, "fungible": Bool, "fee": Nil \\/ (String, Int) } => {\r\n            match (payload.get("contractId").length() > 1, payload.get("contractId").length() < 25) {\r\n              (true, true) => {\r\n                new ch1, ch2, ch3, ch4, ch5 in {\r\n                  TreeHashMap!("get", contractsThm, payload.get("contractId"), *ch1) |\r\n                  for (@exists <- ch1) {\r\n                    if (exists == Nil) {\r\n                      TreeHashMap!("init", "${n}", true, *ch2) |\r\n                      TreeHashMap!("init", "${n}", true, *ch4) |\r\n                      TreeHashMap!("set", contractsThm, payload.get("contractId"), "exists", *ch3) |\r\n                      for (@pursesThm <- ch2; @pursesDataThm <- ch4; _ <- ch3) {\r\n\r\n                        for (@superKeys <- @(*vault, "boxesSuperKeys", boxId)) {\r\n                          @(*vault, "boxesSuperKeys", boxId)!(\r\n                            superKeys.union(Set(payload.get("contractId")))\r\n                          )\r\n                        } |\r\n\r\n                        // purses tree hash map\r\n                        @(*vault, "purses", payload.get("contractId"))!(pursesThm) |\r\n\r\n                        // purses data tree hash map\r\n                        @(*vault, "pursesData", payload.get("contractId"))!(pursesDataThm) |\r\n\r\n                        // config\r\n                        @(*vault, "contractConfig", payload.get("contractId"))!(\r\n                          payload.set("locked", false).set("counter", 1).set("version", "${e}").set("fee", payload.get("fee"))\r\n                        ) |\r\n\r\n                        new superKeyCh in {\r\n                          // return the bundle+ super key\r\n                          @return!((true, bundle+{*superKeyCh})) |\r\n\r\n                          for (@("LOCK", return2) <= superKeyCh) {\r\n                            for (@contractConfig <<- @(*vault, "contractConfig", payload.get("contractId"))) {\r\n                              if (contractConfig.get("locked") == true) {\r\n                                @return2!("error: contract is already locked")\r\n                              } else {\r\n                                for (_ <- @(*vault, "contractConfig", payload.get("contractId"))) {\r\n                                  @(*vault, "contractConfig", payload.get("contractId"))!(contractConfig.set("locked", true)) |\r\n                                  @return2!((true, Nil))\r\n                                }\r\n                              }\r\n                            }\r\n                          } |\r\n\r\n                          for (@("CREATE_PURSES", createPursesPayload, return2) <= superKeyCh) {\r\n                            for (@contractConfig <<- @(*vault, "contractConfig", payload.get("contractId"))) {\r\n                              if (contractConfig.get("locked") == true) {\r\n                                @return2!("error: contract is locked")\r\n                              } else {\r\n                                createPursesCh!((createPursesPayload, payload.get("contractId"), return2))\r\n                              }\r\n                            }\r\n                          }\r\n                        }\r\n                      }\r\n                    } else {\r\n                      @return!("error: contract id already exists")\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n              _ => {\r\n                @return!("error: invalid contract id")\r\n              }\r\n            }\r\n          }\r\n          _ => {\r\n            @return!("error: invalid payload")\r\n          }\r\n        }\r\n      } |\r\n\r\n\r\n      for (@("UPDATE_PURSE_PRICE", payload2, return2) <= @boxCh) {\r\n        new ch3, ch4, ch5 in {\r\n          match payload2 {\r\n            { "price": Int \\/ Nil, "contractId": String, "purseId": String } => {\r\n              getBoxCh!((boxId, *ch3)) |\r\n              for (@box <- ch3) {\r\n                if (box != Nil) {\r\n                  getPurseCh!((box, payload2.get("contractId"), payload2.get("purseId"), *ch4)) |\r\n                  for (@purse <- ch4) {\r\n                    if (purse != Nil) {\r\n                      for (@pursesThm <<- @(*vault, "purses", payload2.get("contractId"))) {\r\n                        TreeHashMap!("set", pursesThm, payload2.get("purseId"), purse.set("price", payload2.get("price")), *ch5) |\r\n                        for (_ <- ch5) {\r\n                          @return2!((true, Nil))\r\n                        }\r\n                      }\r\n                    } else {\r\n                      @return2!("error: purse not found")\r\n                    }\r\n                  }\r\n                } else {\r\n                  @return2!("error: CRITICAL box not found")\r\n                }\r\n              }\r\n            }\r\n            _ => {\r\n              @return2!("error: invalid payload for update price")\r\n            }\r\n          }\r\n        }\r\n      } |\r\n\r\n      for (@("UPDATE_PURSE_DATA", payload2, return2) <= @boxCh) {\r\n        new ch3, ch4, ch5 in {\r\n          match payload2 {\r\n            { "data": _, "contractId": String, "purseId": String } => {\r\n              getBoxCh!((boxId, *ch3)) |\r\n              for (@box <- ch3) {\r\n                if (box != Nil) {\r\n                  getPurseCh!((box, payload2.get("contractId"), payload2.get("purseId"), *ch4)) |\r\n                  for (@purse <- ch4) {\r\n                    if (box != Nil) {\r\n                      for (@pursesDataThm <<- @(*vault, "pursesData", payload2.get("contractId"))) {\r\n                        TreeHashMap!("set", pursesDataThm, payload2.get("purseId"), payload2.get("data"), *ch5) |\r\n                        for (_ <- ch5) {\r\n                          @return2!((true, Nil))\r\n                        }\r\n                      }\r\n                    } else {\r\n                       @return2!("error: purse not found")\r\n                    }\r\n                  }\r\n                } else {\r\n                  @return2!("error: CRITICAL box not found")\r\n                }\r\n              }\r\n            }\r\n            _ => {\r\n              @return2!("error: invalid payload for update data")\r\n            }\r\n          }\r\n        }\r\n      } |\r\n\r\n      for (@("WITHDRAW", payload2, return2) <= @boxCh) {\r\n        new ch3, ch4, ch5, ch6, ch7, ch8, ch9, ch10, ch11, proceedWithdrawCh, mergeCh, mergeOkCh in {\r\n          match payload2 {\r\n            { "quantity": Int, "contractId": String, "purseId": String, "toBoxId": String, "merge": Bool } => {\r\n              getContractPursesThmCh!((payload2.get("contractId"), *ch4)) |\r\n              getBoxCh!((payload2.get("toBoxId"), *ch6)) |\r\n              getBoxCh!((boxId, *ch10)) |\r\n              for (@pursesThm <- ch4; @toBox <- ch6; @box <- ch10) {\r\n                match (pursesThm != Nil, toBox != Nil, box != Nil) {\r\n                  (true, true, true) => {\r\n                    getPurseCh!((box, payload2.get("contractId"), payload2.get("purseId"), *ch9)) |\r\n                    for (@purse <- ch9) {\r\n                      if (purse == Nil) {\r\n                        @return2!("error: purse does not exist")\r\n                      } else {\r\n                        if (purse.get("id") != "0") {\r\n                          proceedWithdrawCh!((pursesThm, purse))\r\n                        } else {\r\n                          @return2!("error: withdraw from special nft 0 is forbidden")\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n                  _ => {\r\n                    @return2!("error: contract or recipient box does not exist")\r\n                  }\r\n                }\r\n              }\r\n            }\r\n            _ => {\r\n              @return2!("error: invalid payload for withdraw")\r\n            }\r\n          } |\r\n\r\n          for (@(pursesThm, purse) <- proceedWithdrawCh) {\r\n\r\n            // the withdrawer should not be able to choose if\r\n            // tokens in recipient box will or will not be \r\n            // merged, except if he withdraws to himself\r\n            mergeCh!(payload2.get("merge")) |\r\n            if (payload2.get("toBoxId") != boxId) {\r\n              for (_ <- mergeCh) {\r\n                mergeOkCh!(true)\r\n              }\r\n            } else {\r\n              for (@m <- mergeCh) {\r\n                mergeOkCh!(m)\r\n              }\r\n            } |\r\n\r\n            for (@merge <- mergeOkCh) {\r\n              match (\r\n                purse.get("quantity") - payload2.get("quantity") >= 0,\r\n                purse.get("quantity") > 0,\r\n                purse.get("quantity") - payload2.get("quantity") > 0\r\n              ) {\r\n\r\n                // ajust quantity in first purse, create a second purse\r\n                // associated with toBoxId\r\n                (true, true, true) => {\r\n                  TreeHashMap!("set", pursesThm, payload2.get("purseId"), purse.set("quantity", purse.get("quantity") - payload2.get("quantity")),  *ch5) |\r\n                  for (_ <- ch5) {\r\n                    makePurseCh!((\r\n                      payload2.get("contractId"),\r\n                      purse\r\n                        .set("price", Nil)\r\n                        .set("quantity", payload2.get("quantity"))\r\n                        .set("boxId", payload2.get("toBoxId")),\r\n                      Nil,\r\n                      merge,\r\n                      return2\r\n                    ))\r\n                  }\r\n                }\r\n\r\n                // remove first purse, create a second purse\r\n                // associated with toBoxId\r\n                (true, true, false) => {\r\n                  TreeHashMap!("set", pursesThm, payload2.get("purseId"), Nil,  *ch5) |\r\n                  for (@pursesDataThm <<- @(*vault, "pursesData", payload2.get("contractId"))) {\r\n                    TreeHashMap!(\r\n                      "get",\r\n                      pursesDataThm,\r\n                      payload2.get("purseId"),\r\n                      *ch7\r\n                    ) |\r\n                    for (_ <- ch5; @data <- ch7) {\r\n                      TreeHashMap!(\r\n                        "set",\r\n                        pursesDataThm,\r\n                        payload2.get("purseId"),\r\n                        Nil,\r\n                        *ch11\r\n                      ) |\r\n                      for (_ <- ch11) {\r\n                        removePurseInBoxCh!((boxId, payload2.get("contractId"), payload2.get("purseId"), *ch8)) |\r\n                        for (@r <- ch8) {\r\n                          match r {\r\n                            String => {\r\n                              @return2!(r)\r\n                            }\r\n                            _ => {\r\n                              makePurseCh!((\r\n                                payload2.get("contractId"),\r\n                                purse\r\n                                  .set("price", Nil)\r\n                                  .set("boxId", payload2.get("toBoxId")),\r\n                                data,\r\n                                merge,\r\n                                return2\r\n                              )) \r\n                            }\r\n                          }\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n                _ => {\r\n                  @return2!("error: cannot withdraw, quantity in payload is superior to existing purse quantity")\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      } |\r\n\r\n      for (@(amount, contractConfig, return2) <= calculateFeeCh) {\r\n        if (contractConfig.get("fee") == Nil) {\r\n          @return2!((amount, 0, Nil))\r\n        } else {\r\n          match amount * contractConfig.get("fee").nth(1) / 100000 {\r\n            feeAmount => {\r\n              @return2!((amount - feeAmount, feeAmount, contractConfig.get("fee").nth(0)))\r\n            }\r\n          }\r\n        }\r\n      } |\r\n\r\n      for (@("PURCHASE", payload2, return2) <= @boxCh) {\r\n        match payload2 {\r\n          { "quantity": Int, "contractId": String, "merge": Bool, "purseId": String, "newId": Nil \\/ String, "data": _, "purseRevAddr": _, "purseAuthKey": _ } => {\r\n            new ch3, ch4, ch5, ch6, ch7, step2Ch, ch20, ch21, ch22, ch23, ch24, ch25, ch26, ch27, ch28, step3Ch, rollbackCh, ch30, ch31, ch32, ch33, ch34, ch35, ch36, ch37, step4Ch, ch40, ch41, ch42, ch43, ch44, ch45, ch46, ch47, ch48, step5Ch, ch50, ch51, ch52, ch53 in {\r\n\r\n              // STEP 1\r\n              // check box, purse\r\n              getBoxCh!((boxId, *ch3)) |\r\n              for (@box <- ch3) {\r\n                if (box != Nil) {\r\n                  getContractPursesThmCh!((payload2.get("contractId"), *ch4)) |\r\n                  getContractPursesDataThmCh!((payload2.get("contractId"), *ch5)) |\r\n                  for (@pursesThm <- ch4; @pursesDataThm <- ch5) {\r\n                    if (pursesThm != Nil) {\r\n                      TreeHashMap!("get", pursesThm, payload2.get("purseId"), *ch6) |\r\n                      TreeHashMap!("get", pursesDataThm, payload2.get("purseId"), *ch7)\r\n                    } else {\r\n                      @return2!("error: contract not found")\r\n                    } |\r\n                    for (@purse <- ch6; @purseData <- ch7) {\r\n                      if (purse != Nil) {\r\n                        step2Ch!((pursesThm, pursesDataThm, purse, purseData))\r\n                      } else {\r\n                        @return2!("error: purse not found")\r\n                      }\r\n                    }\r\n                  }\r\n                } else {\r\n                  @return2!("error: CRITICAL box not found")\r\n                }\r\n              } |\r\n\r\n              // STEP 2\r\n              // transfer total amount to temporary escrow purse\r\n              // check that both emitter and recipient vault exist\r\n              for (@(pursesThm, pursesDataThm, purse, purseData) <- step2Ch) {\r\n                match (\r\n                  purse.get("price"),\r\n                  purse.get("quantity") > 0,\r\n                  payload2.get("quantity") > 0,\r\n                  purse.get("quantity") >= payload2.get("quantity")\r\n                ) {\r\n                  (Int, true, true, true) => {\r\n                    registryLookup!(\`rho:rchain:revVault\`, *ch20) |\r\n\r\n                    for (@boxConfig <<- @(*vault, "boxConfig", purse.get("boxId"))) {\r\n                      revAddress!("fromPublicKey", boxConfig.get("publicKey").hexToBytes(), *ch21)\r\n                    } |\r\n\r\n                    for (@contractConfig <<- @(*vault, "contractConfig", payload2.get("contractId"))) {\r\n                      calculateFeeCh!((payload2.get("quantity") * purse.get("price"), contractConfig, *ch22))\r\n                    } |\r\n\r\n                    for (@(_, RevVault) <- ch20; @ownerRevAddress <- ch21; @amountAndFeeAmount <- ch22) {\r\n                      match (\r\n                        payload2.get("purseRevAddr"),\r\n                        ownerRevAddress,\r\n                        amountAndFeeAmount.nth(0),\r\n                        amountAndFeeAmount.nth(1),\r\n                        amountAndFeeAmount.nth(2)\r\n                      ) {\r\n                        (emitterRevAddress, recipientRevAddress, amount, feeAmount, feePublicKey) => {\r\n                          @RevVault!("findOrCreate", emitterRevAddress, *ch23) |\r\n                          @RevVault!("findOrCreate", recipientRevAddress, *ch24) |\r\n                          for (@a <- ch23; @b <- ch24) {\r\n                            match (a, b) {\r\n                              ((true, purseVaultEmitter),  (true, purseVaultRecipient)) => {\r\n                                new unf in {\r\n                                  @RevVault!("unforgeableAuthKey", *unf, *ch25) |\r\n                                  revAddress!("fromUnforgeable", *unf, *ch26) |\r\n                                  for (@escrowPurseAuthKey <- ch25; @escrowPurseRevAddr <- ch26) {\r\n                                    @RevVault!("findOrCreate", escrowPurseRevAddr, *ch27) |\r\n                                    for (@(true, escrowPurseVault) <- ch27) {\r\n                                      @purseVaultEmitter!("transfer", escrowPurseRevAddr, amount + feeAmount, payload2.get("purseAuthKey"), *ch28) |\r\n                                      for (@escrowTransferResult <- ch28) {\r\n                                        match escrowTransferResult {\r\n                                          (true, Nil) => {\r\n                                            stdout!("transfer to escrow purse successful") |\r\n                                            step3Ch!((pursesThm, pursesDataThm, purse, purseData, RevVault, escrowPurseRevAddr, escrowPurseAuthKey, emitterRevAddress, recipientRevAddress, amount, feeAmount, feePublicKey))\r\n                                          }\r\n                                          _ => {\r\n                                            stdout!(escrowTransferResult) |\r\n                                            @return2!("error: escrow transfer went wrong, invalid rev purse in payload")\r\n                                          }\r\n                                        }\r\n                                      }\r\n                                    }\r\n                                  }\r\n                                }\r\n                              }\r\n                              _ => {\r\n                                @return2!("error: could not find or create vaults")\r\n                              }\r\n                            }\r\n                          }\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n                  _ => {\r\n                    @return2!("error: quantity not available or purse not for sale")\r\n                  }\r\n                }\r\n              } |\r\n\r\n              // STEP 3\r\n              // listen on rollbackCh and prepare to reset state to original\r\n              // if step 4 or 5 fails\r\n              // \r\n              for (@(pursesThm, pursesDataThm, purse, purseData, RevVault, escrowPurseRevAddr, escrowPurseAuthKey, emitterRevAddress, recipientRevAddress, amount, feeAmount, feePublicKey) <- step3Ch) {\r\n                for (@message <- rollbackCh) {\r\n                  TreeHashMap!("set", pursesThm, purse.get("id"), purse,  *ch30) |\r\n                  TreeHashMap!("set", pursesDataThm, purse.get("id"), purseData,  *ch31) |\r\n                  if (purse.get("quantity") - payload2.get("quantity") == 0) {\r\n                    savePurseInBoxCh!((payload2.get("contractId"), purse.get("boxId"), purse.get("id"), true, *ch32))\r\n                  } else {\r\n                    // the purse has not been removed from box\r\n                    ch32!((true, Nil))\r\n                  } |\r\n                  for (_ <- ch30; _ <- ch31; @a <- ch32) {\r\n                    match a {\r\n                      String => {\r\n                        stdout!("error: CRITICAL could not rollback after makePurse error") |\r\n                        @return2!("error: CRITICAL could not rollback after makePurse error")\r\n                      }\r\n                      _ => {\r\n                        @RevVault!("findOrCreate", escrowPurseRevAddr, *ch33) |\r\n                        for (@(true, purseVaultEscrow) <- ch33) {\r\n                          @purseVaultEscrow!("transfer", emitterRevAddress, amount + feeAmount, escrowPurseAuthKey, *ch34) |\r\n                          for (@r <- ch34) {\r\n                            match r {\r\n                              (true, Nil) => {\r\n                                @return2!("error: rollback successful, makePurse error, transaction was rolled backed, emitter purse was reimbursed " ++ message)\r\n                              }\r\n                              _ => {\r\n                                stdout!(r) |\r\n                                stdout!("error: CRITICAL, makePurse error, could rollback but could not reimburse after makePurse error" ++ message) |\r\n                                @return2!("error: CRITICAL, makePurse error, could rollback but could not reimburse after makePurse error" ++ message)\r\n                              }\r\n                            }\r\n                          }\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n                } |\r\n                step4Ch!((pursesThm, pursesDataThm, purse, purseData, RevVault, escrowPurseRevAddr, escrowPurseAuthKey, emitterRevAddress, recipientRevAddress, amount, feeAmount, feePublicKey))\r\n              } |\r\n\r\n              // STEP 4\r\n              // try to makePurse\r\n              for (@(pursesThm, pursesDataThm, purse, purseData, RevVault, escrowPurseRevAddr, escrowPurseAuthKey, emitterRevAddress, recipientRevAddress, amount, feeAmount, feePublicKey) <- step4Ch) {\r\n                for (@makePurseResult <- ch43) {\r\n                  match makePurseResult {\r\n                    String => {\r\n                      rollbackCh!(makePurseResult)\r\n                    }\r\n                    _ => {\r\n                      step5Ch!((pursesThm, pursesDataThm, purse, purseData, RevVault, escrowPurseRevAddr, escrowPurseAuthKey, emitterRevAddress, recipientRevAddress, amount, feeAmount, feePublicKey))\r\n                    }\r\n                  }\r\n                } |\r\n\r\n                // remove completely purse and create a new one\r\n                // with same id, id may be changed by makePurse\r\n                // depending on fungible or not\r\n                if (purse.get("quantity") - payload2.get("quantity") == 0) {\r\n                  TreeHashMap!("set", pursesThm, purse.get("id"), Nil,  *ch40) |\r\n                  TreeHashMap!("set", pursesDataThm, purse.get("id"), Nil,  *ch41) |\r\n                  removePurseInBoxCh!((purse.get("boxId"), payload2.get("contractId"), purse.get("id"), *ch42)) |\r\n\r\n                  for (_ <- ch40; _ <- ch41; _ <- ch42) {\r\n                    makePurseCh!((\r\n                      payload2.get("contractId"),\r\n                      // keep quantity and type of existing purse\r\n                      purse\r\n                        .set("boxId", boxId)\r\n                        .set("price", Nil)\r\n                        // will only considered for nft, purchase from purse "0"\r\n                        .set("newId", payload2.get("newId")),\r\n                      payload2.get("data"),\r\n                      payload2.get("merge"),\r\n                      *ch43\r\n                    ))\r\n                  }\r\n                } else {\r\n                  // just update quantity of current purse, and\r\n                  //  create another one with right quantity\r\n                  TreeHashMap!("set", pursesThm, purse.get("id"), purse.set("quantity", purse.get("quantity") - payload2.get("quantity")),  *ch40) |\r\n\r\n                  for (_ <- ch40) {\r\n                    makePurseCh!((\r\n                      payload2.get("contractId"),\r\n                      purse\r\n                        .set("boxId", boxId)\r\n                        .set("quantity", payload2.get("quantity"))\r\n                        .set("price", Nil)\r\n                        // will only considered for nft, purchase from purse "0"\r\n                        .set("newId", payload2.get("newId")),\r\n                      payload2.get("data"),\r\n                      payload2.get("merge"),\r\n                      *ch43\r\n                    ))\r\n                  }\r\n                }\r\n              } |\r\n\r\n              // STEP 5\r\n              // everything went ok, do final payment\r\n              for (@(pursesThm, pursesDataThm, purse, purseData, RevVault, escrowPurseRevAddr, escrowPurseAuthKey, emitterRevAddress, recipientRevAddress, amount, feeAmount, feePublicKey) <- step5Ch) {\r\n                @RevVault!("findOrCreate", escrowPurseRevAddr, *ch50) |\r\n                for (@(true, purseVaultEscrow) <- ch50) {\r\n                  @purseVaultEscrow!("transfer", recipientRevAddress, amount, escrowPurseAuthKey, *ch51) |\r\n                  for (@r <- ch51) {\r\n                    match r {\r\n                      (true, Nil) => {\r\n                        if (feeAmount != 0) {\r\n                          revAddress!("fromPublicKey", feePublicKey.hexToBytes(), *ch52) |\r\n                          for (@feeRevAddress <- ch52) {\r\n                            @purseVaultEscrow!("transfer", feeRevAddress, feeAmount, escrowPurseAuthKey, *ch53)\r\n                          } |\r\n                          for (@transferFeeReturn <- ch53) {\r\n                            match transferFeeReturn {\r\n                              (true, Nil) => {\r\n                                stdout!("fee transfer successful")\r\n                              }\r\n                              _ => {\r\n                                stdout!("error: CRITICAL could not transfer fee")\r\n                              }\r\n                            }\r\n                          }\r\n                        } |\r\n                        @return2!((true, Nil))\r\n                      }\r\n                      _ => {\r\n                        stdout!("error: CRITICAL, makePurse went fine, but could not do final transfer") |\r\n                        rollbackCh!("error: CRITICAL, makePurse went fine, but could not do final transfer")\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n          _ => {\r\n            @return2!("error: invalid payload")\r\n          }\r\n        }\r\n      }\r\n    } |\r\n\r\n\r\n\r\n    /* ###################################################################################### */\r\n    /*                             register public entry channel                              */\r\n    insertArbitrary!(bundle+{*entryCh}, *entryUriCh) |\r\n\r\n    for (entryUri <- entryUriCh) {\r\n      basket!({\r\n        "status": "completed",\r\n        "registryUri": *entryUri\r\n      }) |\r\n      stdout!(("URI", *entryUri))\r\n    }\r\n  } \r\n\r\n   \r\n}\r\n`,r.insertRegistry=({})=>'new return(`rho:rchain:deployId`),\r\n  insertArbitrary(`rho:registry:insertArbitrary`)\r\n  in {\r\n  new uriCh, valueCh in {\r\n    insertArbitrary!("My value", *uriCh) |\r\n    for (@uri <- uriCh) {\r\n      return!(("URI", uri))\r\n    }\r\n  }\r\n}\r\n',r.master=({n:r,version:e,depthcontract:n,depth:t})=>`new \r\n  basket,\r\n\r\n  entryCh,\r\n  entryUriCh,\r\n\r\n  byteArraySafeToStoreCh,\r\n  iterateOnThmKeysCh,\r\n  createPursesCh,\r\n  makePurseCh,\r\n  calculateFeeCh,\r\n  pursesTreeHashMapCh,\r\n  pursesForSaleTreeHashMapCh,\r\n  initializeOCAPOnBoxCh,\r\n\r\n    // dont use multi line /* */ -> error\r\n    // 'vault is the ultimate accessibility unforgeable in\r\n    // master contract, every data is stored in channels that\r\n    // derives from *vault unforgeable name\r\n\r\n    // // tree hash map of purses :\r\n    // thm <- @(*vault, "purses", "contract03")\r\n\r\n    // // tree hash map of purses data :\r\n    // thm <- @(*vault, "pursesData", "contract03")\r\n\r\n    // // contract's configs\r\n    // config <- @(*vault, "contractConfig", "contract03")\r\n\r\n    // // boxes\r\n    // box <- @(*vault, "boxes", "box01")\r\n    \r\n    // // box's configs\r\n    // config <- @(*vault, "boxConfig", "box01")\r\n\r\n    // // super keys of a given box\r\n    // superKeys <- @(*vault, "boxesSuperKeys", "box01")'\r\n\r\n  vault,\r\n\r\n  \r\n    // boxesThm and contractsThm only store the list\r\n    // of existing contracts / boxes, ex:\r\n    // boxesThm:\r\n    // { "box1": "exists", "mycoolbox": "exists" }\r\n\r\n    // Then each box is a Map stored at a unique channel\r\n    // (see above) and has the following structure:\r\n    // {\r\n    //   [contractId: string]: Set(purseId: string)\r\n    // }\r\n\r\n    // Each contract has its own tree hash map, and\r\n    // have the following structure:\r\n    // pursesThm:\r\n    // {\r\n    //   "1": { quantity: 2, type: "0", box: "box1", price: Nil},\r\n    //   "2": { quantity: 12, type: "0", box: "box1", price: 2},\r\n    // }\r\n  \r\n  boxesReadyCh,\r\n  contractsReadyCh,\r\n\r\n  TreeHashMap,\r\n\r\n  savePurseInBoxCh,\r\n  removePurseInBoxCh,\r\n  getBoxCh,\r\n  getPurseCh,\r\n  getContractPursesThmCh,\r\n  getContractPursesDataThmCh,\r\n\r\n  insertArbitrary(\`rho:registry:insertArbitrary\`),\r\n  revAddress(\`rho:rev:address\`),\r\n  registryLookup(\`rho:registry:lookup\`),\r\n  stdout(\`rho:rchain:deployId\`)\r\n\r\nin {\r\n\r\n  for (@boxesThm <- boxesReadyCh; @contractsThm <- contractsReadyCh) {\r\n\r\n    // returns the box if exists\r\n    for (@(boxId, return) <= getBoxCh) {\r\n      new ch1 in {\r\n        TreeHashMap!("get", boxesThm, boxId, *ch1) |\r\n        for (@exists <- ch1) {\r\n          if (exists == "exists") {\r\n            for (@box <<- @(*vault, "boxes", boxId)) {\r\n              @return!(box)\r\n            }\r\n          } else {\r\n            @return!(Nil)\r\n          }\r\n        }\r\n      }\r\n    } |\r\n\r\n    // returns the purse if exists AND is associated with box\r\n    for (@(box, contractId, purseId, return) <= getPurseCh) {\r\n      new ch1 in {\r\n        if (box.get(contractId) == Nil) {\r\n          @return!(Nil)\r\n        } else {\r\n          if (box.get(contractId).contains(purseId) == true) {\r\n            getContractPursesThmCh!((contractId, *ch1)) |\r\n            for (@pursesThm <- ch1) {\r\n              TreeHashMap!("get", pursesThm, purseId, return)\r\n            }\r\n          } else {\r\n            @return!(Nil)\r\n          }\r\n        }\r\n      }\r\n    } |\r\n\r\n    // returns the tree hash map of the contract's purses if exists\r\n    for (@(contractId, return) <= getContractPursesThmCh) {\r\n      new ch1 in {\r\n        TreeHashMap!("get", contractsThm, contractId, *ch1) |\r\n        for (@exists <- ch1) {\r\n          if (exists == "exists") {\r\n            for (@pursesThm <<- @(*vault, "purses", contractId)) {\r\n              @return!(pursesThm)\r\n            }\r\n          } else {\r\n            @return!(Nil)\r\n          }\r\n        }\r\n      }\r\n    } |\r\n\r\n    // returns the tree hash map of the contract's purses data if exists\r\n    for (@(contractId, return) <= getContractPursesDataThmCh) {\r\n      new ch1 in {\r\n        TreeHashMap!("get", contractsThm, contractId, *ch1) |\r\n        for (@exists <- ch1) {\r\n          if (exists == "exists") {\r\n            for (@pursesDataThm <<- @(*vault, "pursesData", contractId)) {\r\n              @return!(pursesDataThm)\r\n            }\r\n          } else {\r\n            @return!(Nil)\r\n          }\r\n        }\r\n      }\r\n    } |\r\n  \r\n    // remove purse in box, if found\r\n    for (@(boxId, contractId, purseId, return) <= removePurseInBoxCh) {\r\n      new ch1 in {\r\n        getBoxCh!((boxId, *ch1)) |\r\n        for (@box <- ch1) {\r\n          if (box == Nil) {\r\n            @return!("error: CRITICAL box not found")\r\n          } else {\r\n            if (box.get(contractId) == Nil) {\r\n              @return!("error: CRITICAL purse not found")\r\n            } else {\r\n              if (box.get(contractId).contains(purseId) == false) {\r\n                @return!("error: CRITICAL purse not found")\r\n              } else {\r\n                for (_ <- @(*vault, "boxes", boxId)) {\r\n                  stdout!(contractId ++ "/" ++ boxId ++ " purse " ++ purseId ++ " removed from box") |\r\n                  @(*vault, "boxes", boxId)!(box.set(contractId, box.get(contractId).delete(purseId))) |\r\n                  @return!((true, Nil))\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } |\r\n\r\n    // save purse id in box\r\n    for (@(contractId, boxId, purseId, merge, return) <= savePurseInBoxCh) {\r\n      new ch1, ch2, ch3, iterateAndMergePursesCh in {\r\n\r\n        getBoxCh!((boxId, *ch1)) |\r\n        getContractPursesThmCh!((contractId, *ch2)) |\r\n\r\n        for (@box <- ch1; @pursesThm <- ch2) {\r\n          match (box != Nil, pursesThm != Nil) {\r\n            (true, true) => {\r\n              if (box.get(contractId) == Nil) {\r\n                for (_ <- @(*vault, "boxes", boxId)) {\r\n                  stdout!(contractId ++ "/" ++ boxId ++ " purse " ++ purseId ++ " saved to box") |\r\n                  @(*vault, "boxes", boxId)!(box.set(contractId, Set(purseId))) |\r\n                  @return!((true, Nil))\r\n                }\r\n              } else {\r\n                if (box.get(contractId).contains(purseId) == false) {\r\n                  for (@contractConfig <<- @(*vault, "contractConfig", contractId)) {\r\n                    match (contractConfig.get("fungible") == true, merge) {\r\n                      (true, true) => {\r\n                        for (@pursesThm <<- @(*vault, "purses", contractId)) {\r\n                          TreeHashMap!("get", pursesThm, purseId, *ch3) |\r\n                          for (@purse <- ch3) {\r\n                            iterateAndMergePursesCh!((box, purse, pursesThm))\r\n                          }\r\n                        }\r\n                      }\r\n                      _ => {\r\n                        for (_ <- @(*vault, "boxes", boxId)) {\r\n                          stdout!(contractId ++ "/" ++ boxId ++ " purse " ++ purseId ++ " saved to box") |\r\n                          @(*vault, "boxes", boxId)!(box.set(\r\n                            contractId,\r\n                            box.get(contractId).union(Set(purseId))\r\n                          )) |\r\n                          @return!((true, Nil))\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n                } else {\r\n                  @return!("error: CRITICAL, purse already exists in box")\r\n                }\r\n              }\r\n            }\r\n          }\r\n        } |\r\n        // if contract is fungible, we may find a\r\n        // purse with same .price and .type property\r\n        // if found, then merge and delete current purse\r\n        for (@(box, purse, pursesThm) <- iterateAndMergePursesCh) {\r\n          new tmpCh, itCh in {\r\n            for (ids <= itCh) {\r\n              match *ids {\r\n                Set() => {\r\n                  stdout!(contractId ++ "/" ++ boxId ++ " purse " ++ purse.get("id") ++ " saved to box") |\r\n                  for (_ <- @(*vault, "boxes", boxId)) {\r\n                     @(*vault, "boxes", boxId)!(box.set(contractId, Set(purseId))) |\r\n                     @return!((true, Nil))\r\n                  }\r\n                }\r\n                Set(last) => {\r\n                  new ch4, ch5, ch6, ch7 in {\r\n                    TreeHashMap!("get", pursesThm, last, *ch4) |\r\n                    for (@purse2 <- ch4) {\r\n                      match (purse2.get("type") == purse.get("type"), purse2.get("price") == purse.get("price")) {\r\n                        (true, true) => {\r\n                          TreeHashMap!(\r\n                            "set",\r\n                            pursesThm,\r\n                            last,\r\n                            purse2.set("quantity", purse2.get("quantity") + purse.get("quantity")),\r\n                            *ch5\r\n                          ) |\r\n                          TreeHashMap!(\r\n                            "set",\r\n                            pursesThm,\r\n                            purse.get("id"),\r\n                            Nil,\r\n                            *ch6\r\n                          ) |\r\n                          for (@pursesDataThm <<- @(*vault, "pursesData", contractId)) {\r\n                            TreeHashMap!(\r\n                              "set",\r\n                              pursesDataThm,\r\n                              purse.get("id"),\r\n                              Nil,\r\n                              *ch7\r\n                            )\r\n                          } |\r\n                          for (_ <- ch5; _ <- ch6; _ <- ch7) {\r\n                            stdout!(contractId ++ "/" ++ boxId ++ " purse " ++ purse.get("id") ++ " merged into purse " ++ purse2.get("id")) |\r\n                            @return!((true, Nil))\r\n                          }\r\n                        }\r\n                        _ => {\r\n                          stdout!(contractId ++ "/" ++ boxId ++ " purse " ++ purse.get("id") ++ " saved to box") |\r\n                          for (_ <- @(*vault, "boxes", boxId)) {\r\n                            @(*vault, "boxes", boxId)!(box.set(\r\n                              contractId,\r\n                              box.get(contractId).union(Set(purse.get("id")))\r\n                            )) |\r\n                            @return!((true, Nil))\r\n                          }\r\n                        }\r\n                      }\r\n                    }\r\n\r\n                  }\r\n                }\r\n                Set(first ... rest) => {\r\n                  new ch4, ch5, ch6, ch7 in {\r\n                    TreeHashMap!("get", pursesThm, first, *ch4) |\r\n                    for (@purse2 <- ch4) {\r\n                      match (purse2.get("type") == purse.get("type"), purse2.get("price") == purse.get("price")) {\r\n                        (true, true) => {\r\n                          TreeHashMap!(\r\n                            "set",\r\n                            pursesThm,\r\n                            first,\r\n                            purse2.set("quantity", purse2.get("quantity") + purse.get("quantity")),\r\n                            *ch5\r\n                          ) |\r\n                          TreeHashMap!(\r\n                            "set",\r\n                            pursesThm,\r\n                            purse.get("id"),\r\n                            Nil,\r\n                            *ch6\r\n                          ) |\r\n                          for (@pursesDataThm <<- @(*vault, "pursesData", contractId)) {\r\n                            TreeHashMap!(\r\n                              "set",\r\n                              pursesDataThm,\r\n                              purse.get("id"),\r\n                              Nil,\r\n                              *ch7\r\n                            )\r\n                          } |\r\n                          for (_ <- ch5; _ <- ch6; _ <- ch7) {\r\n                            stdout!(contractId ++ "/" ++ boxId ++ " purse " ++ purse.get("id") ++ " merged into purse " ++ purse2.get("id")) |\r\n                            @return!((true, Nil))\r\n                          }\r\n                        }\r\n                        _ => {\r\n                          itCh!(rest)\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            } |\r\n            itCh!(box.get(contractId))\r\n          }\r\n        }\r\n      }\r\n    } |\r\n\r\n    \r\n    // makePurseCh\r\n    // only place where new purses are created:\r\n    // PURCHASE, WITHDRAW, and CREATE_PURSES may call this channel\r\n\r\n    // depending on if .fungible is true or false, it decides\r\n    // which id to give to the new purse, then it creates the\r\n    // purse and saves to box\r\n    \r\n    for (@(contractId, properties, data, merge, return) <= makePurseCh) {\r\n      new ch1, ch2, ch3, ch4, idAndQuantityCh in {\r\n        for (@contractConfig <<- @(*vault, "contractConfig", contractId)) {\r\n          if (contractConfig.get("fungible") == true) {\r\n            for (_ <- @(*vault, "contractConfig", contractId)) {\r\n              @(*vault, "contractConfig", contractId)!(contractConfig.set("counter", contractConfig.get("counter") + 1))\r\n            } |\r\n            idAndQuantityCh!({ "id": "${r}" %% { "n": contractConfig.get("counter") }, "quantity": properties.get("quantity") })\r\n          } else {\r\n            for (@pursesThm <<- @(*vault, "purses", contractId)) {\r\n              TreeHashMap!("get", pursesThm, properties.get("id"), *ch1) |\r\n              for (@existingPurse <- ch1) {\r\n\r\n                // check that nft does not exist\r\n                if (existingPurse == Nil) {\r\n                  if (properties.get("id") == "0") {\r\n                    idAndQuantityCh!({ "id": properties.get("id"), "quantity": properties.get("quantity") })\r\n                  } else {\r\n                    idAndQuantityCh!({ "id": properties.get("id"), "quantity": 1 })\r\n                  }\r\n                } else {\r\n\r\n                  // nft with id: "0" is a special nft from which\r\n                  // anyone can mint a nft that does not exist yet\r\n                  // used by dappy name system for example\r\n                  if (properties.get("id") == "0") {\r\n                    TreeHashMap!("get", pursesThm, properties.get("newId"), *ch2) |\r\n                    for (@purseWithNewId <- ch2) {\r\n                      match (properties.get("newId"), purseWithNewId) {\r\n                        (String, Nil) => {\r\n                          idAndQuantityCh!({ "id": properties.get("newId"), "quantity": 1 })\r\n                        }\r\n                        _ => {\r\n                          @return!("error: no .newId in payload or .newId already exists")\r\n                        }\r\n                      }\r\n                    }\r\n                  } else {\r\n                    @return!("error: purse id already exists")\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        } |\r\n        for (@idAndQuantity <- idAndQuantityCh) {\r\n          match properties\r\n            .set("id", idAndQuantity.get("id"))\r\n            .set("quantity", idAndQuantity.get("quantity"))\r\n            .delete("newId")\r\n          {\r\n            purse => {\r\n              match (purse, purse.get("id").length() > 0, purse.get("id").length() < 25) {\r\n                ({\r\n                  "quantity": Int,\r\n                  "type": String,\r\n                  "boxId": String,\r\n                  "id": String,\r\n                  "price": Nil \\/ Int\r\n                }, true, true) => {\r\n                  for (@pursesDataThm <<- @(*vault, "pursesData", contractId)) {\r\n                    for (@pursesThm <<- @(*vault, "purses", contractId)) {\r\n                      TreeHashMap!("set", pursesThm, purse.get("id"), purse, *ch3) |\r\n                      TreeHashMap!("set", pursesDataThm, purse.get("id"), data, *ch4)\r\n                    }\r\n                  } |\r\n\r\n                  for (_ <- ch3; _ <- ch4) {\r\n                    savePurseInBoxCh!((contractId, purse.get("boxId"), purse.get("id"), merge, return))\r\n                  }\r\n                }\r\n                _ => {\r\n                  @return!("error: invalid purse, one of the following errors: id length must be between length 1 and 24")\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } |\r\n\r\n    for (@(payload, contractId, return) <= createPursesCh) {\r\n      new itCh, sizeCh, createdPursesesCh, saveKeyAndBagCh in {\r\n        createdPursesesCh!([]) |\r\n        sizeCh!(payload.get("purses").keys().size()) |\r\n        for (@size <- sizeCh) {\r\n          itCh!(payload.get("purses").keys()) |\r\n          for(@set <= itCh) {\r\n            match set {\r\n              Nil => {}\r\n              Set(last) => {\r\n                new ch1, ch2 in {\r\n                  match payload.get("purses").get(last) {\r\n                    {\r\n                      "quantity": Int,\r\n                      "type": String,\r\n                      "id": String,\r\n                      "price": Nil \\/ Int,\r\n                      "boxId": String\r\n                    } => {\r\n                      getBoxCh!((payload.get("purses").get(last).get("boxId"), *ch1)) |\r\n                      for (@box <- ch1) {\r\n                        if (box == Nil) {\r\n                          @return!("error: some purses may have been created until one failed: box not found " ++ payload.get("purses").get(last).get("boxId"))\r\n                        } else {\r\n                          makePurseCh!((\r\n                            contractId,\r\n                            payload.get("purses").get(last),\r\n                            payload.get("data").get(last),\r\n                            true,\r\n                            *ch2\r\n                          )) |\r\n                          for (@r <- ch2) {\r\n                            match r {\r\n                              String => {\r\n                                @return!("error: some purses may have been created until one failed " ++ r)\r\n                              }\r\n                              _ => {\r\n                                @return!((true, Nil))\r\n                              }\r\n                            }\r\n                          }\r\n                        }\r\n                      }\r\n                    }\r\n                    _ => {\r\n                      @return!("error: invalid purse payload, some purses may have been successfuly created")\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n              Set(first ... rest) => {\r\n                new ch1, ch2 in {\r\n                  match payload.get("purses").get(first) {\r\n                    {\r\n                      "quantity": Int,\r\n                      "type": String,\r\n                      "id": String,\r\n                      "price": Nil \\/ Int,\r\n                      "boxId": String\r\n                    } => {\r\n                      getBoxCh!((payload.get("purses").get(first).get("boxId"), *ch1)) |\r\n                      for (@box <- ch1) {\r\n                        if (box == Nil) {\r\n                          @return!("error: some purses may have been created until one failed: box not found " ++ payload.get("purses").get(first).get("boxId"))\r\n                        } else {\r\n                          makePurseCh!((\r\n                            contractId,\r\n                            payload.get("purses").get(first),\r\n                            payload.get("data").get(first),\r\n                            true,\r\n                            *ch2\r\n                          )) |\r\n                          for (@r <- ch2) {\r\n                            match r {\r\n                              String => {\r\n                                @return!("error: some purses may have been created until one failed " ++ r)\r\n                              }\r\n                              _ => {\r\n                                itCh!(rest)\r\n                              }\r\n                            }\r\n                          }\r\n                        }\r\n                      }\r\n                    }\r\n                    _ => {\r\n                      @return!("error: invalid purse payload, some purses may have been successfuly created")\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } |\r\n\r\n    contract iterateOnThmKeysCh(@(ids, thm, return)) = {\r\n      new tmpCh, itCh in {\r\n        for (@(tmpCh, ids) <= itCh) {\r\n          for (tmp <- @tmpCh) {\r\n            match ids {\r\n              Nil => {\r\n                @return!(*tmp)\r\n              }\r\n              Set(last) => {\r\n                new ch1 in {\r\n                  TreeHashMap!("get", thm, last, *ch1) |\r\n                  for (@p <- ch1) {\r\n                    @return!(*tmp.set(last, p))\r\n                  }\r\n                }\r\n              }\r\n              Set(first ... rest) => {\r\n                new ch1 in {\r\n                  TreeHashMap!("get", thm, first, *ch1) |\r\n                  for (@p <- ch1) {\r\n                    @tmpCh!(*tmp.set(first, p)) |\r\n                    itCh!((tmpCh, rest))\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        } |\r\n        tmpCh!({}) |\r\n        itCh!((*tmpCh, ids))\r\n      }\r\n    } |\r\n\r\n    /* ################################################################################## */\r\n    /*                                Public interfaces                                   */\r\n\r\n    for (@("PUBLIC_READ_ALL_PURSES", contractId, return) <= entryCh) {\r\n      new ch1 in {\r\n        getContractPursesThmCh!((contractId, *ch1)) |\r\n        for (@pursesThm <- ch1) {\r\n          if (pursesThm == Nil) {\r\n            @return!("error: contract not found")\r\n          } else {\r\n            TreeHashMap!("getAllValues", pursesThm, return)\r\n          }\r\n        }\r\n      }\r\n    } |\r\n\r\n    for (@("PUBLIC_READ_BOX", boxId, return) <= entryCh) {\r\n      new ch1 in {\r\n        getBoxCh!((boxId, *ch1)) |\r\n        for (@box <- ch1) {\r\n          if (box == Nil) {\r\n            @return!("error: box not found")\r\n          } else {\r\n            for (@superKeys <<- @(*vault, "boxesSuperKeys", boxId)) {\r\n              for (@config <<- @(*vault, "boxConfig", boxId)) {\r\n                @return!(config.union({ "superKeys": superKeys, "purses": box, "version": "${e}" }))\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } |\r\n\r\n    for (@("PUBLIC_READ_PURSES", payload, return) <= entryCh) {\r\n      new ch1 in {\r\n        getContractPursesThmCh!((payload.get("contractId"), *ch1)) |\r\n        for (@pursesThm <- ch1) {\r\n          if (pursesThm == Nil) {\r\n            @return!("error: contract not found")\r\n          } else {\r\n            match payload.get("purseIds").size() < 101 {\r\n              true => {\r\n                iterateOnThmKeysCh!((payload.get("purseIds"), pursesThm, return))\r\n              }\r\n              _ => {\r\n                @return!("error: payload.purseIds must be a Set of strings with max size 100")\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } |\r\n\r\n    for (@("PUBLIC_READ_PURSES_DATA", payload, return) <= entryCh) {\r\n      new ch1 in {\r\n        getContractPursesDataThmCh!((payload.get("contractId"), *ch1)) |\r\n        for (@pursesDataThm <- ch1) {\r\n          if (pursesDataThm == Nil) {\r\n            @return!("error: contract not found")\r\n          } else {\r\n            match payload.get("purseIds").size() < 101 {\r\n              true => {\r\n                iterateOnThmKeysCh!((payload.get("purseIds"), pursesDataThm, return))\r\n              }\r\n              _ => {\r\n                @return!("error: payload.purseIds must be a Set of strings with max size 100")\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } |\r\n\r\n    for (@("PUBLIC_READ_CONFIG", contractId, return) <= entryCh) {\r\n      for (@config <<- @(*vault, "contractConfig", contractId)) {\r\n        @return!(config)\r\n      }\r\n    } |\r\n\r\n    for (@("PUBLIC_REGISTER_BOX", payload, return) <= entryCh) {\r\n      match (payload.get("boxId"), payload.get("publicKey"), payload.get("boxId").length() > 1, payload.get("boxId").length() < 25) {\r\n        (String, String, true, true) => {\r\n          new ch1, ch2, ch3, ch4, ch5, ch6 in {\r\n            registryLookup!(\`rho:rchain:revVault\`, *ch3) |\r\n            for (@(_, RevVault) <- ch3) {\r\n              revAddress!("fromPublicKey", payload.get("publicKey").hexToBytes(), *ch4) |\r\n              for (@a <- ch4) {\r\n                @RevVault!("findOrCreate", a, *ch5) |\r\n                for (@b <- ch5) {\r\n                  match b {\r\n                    (true, vaultFromPublicKey) => {\r\n                      ch6!(true)\r\n                    }\r\n                    _ => {\r\n                      @return!("error: invalid public key, could not get vault")\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            } |\r\n\r\n            TreeHashMap!("get", boxesThm, payload.get("boxId"), *ch1) |\r\n            for (@existingBox <- ch1; _ <- ch6) {\r\n              if (existingBox == Nil) {\r\n                new boxCh in {\r\n                  TreeHashMap!("set", boxesThm, payload.get("boxId"), "exists", *ch2) |\r\n                  for (_ <- ch2) {\r\n                    @(*vault, "boxes", payload.get("boxId"))!({}) |\r\n                    @(*vault, "boxesSuperKeys", payload.get("boxId"))!(Set()) |\r\n                    @(*vault, "boxConfig", payload.get("boxId"))!({ "publicKey": payload.get("publicKey") }) |\r\n                    @return!((true, bundle+{*boxCh})) |\r\n                    initializeOCAPOnBoxCh!((*boxCh, payload.get("boxId")))\r\n                  }\r\n                }\r\n              } else {\r\n                @return!("error: box already exists")\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } |\r\n\r\n    for (@(boxCh, boxId) <= initializeOCAPOnBoxCh) {\r\n\r\n      for (@("PUBLIC_REGISTER_CONTRACT", payload, return) <= @boxCh) {\r\n        match payload {\r\n          { "contractId": String, "fungible": Bool, "fee": Nil \\/ (String, Int) } => {\r\n            match (payload.get("contractId").length() > 1, payload.get("contractId").length() < 25) {\r\n              (true, true) => {\r\n                new ch1, ch2, ch3, ch4, ch5 in {\r\n                  TreeHashMap!("get", contractsThm, payload.get("contractId"), *ch1) |\r\n                  for (@exists <- ch1) {\r\n                    if (exists == Nil) {\r\n                      TreeHashMap!("init", "${n}", true, *ch2) |\r\n                      TreeHashMap!("init", "${n}", true, *ch4) |\r\n                      TreeHashMap!("set", contractsThm, payload.get("contractId"), "exists", *ch3) |\r\n                      for (@pursesThm <- ch2; @pursesDataThm <- ch4; _ <- ch3) {\r\n\r\n                        for (@superKeys <- @(*vault, "boxesSuperKeys", boxId)) {\r\n                          @(*vault, "boxesSuperKeys", boxId)!(\r\n                            superKeys.union(Set(payload.get("contractId")))\r\n                          )\r\n                        } |\r\n\r\n                        // purses tree hash map\r\n                        @(*vault, "purses", payload.get("contractId"))!(pursesThm) |\r\n\r\n                        // purses data tree hash map\r\n                        @(*vault, "pursesData", payload.get("contractId"))!(pursesDataThm) |\r\n\r\n                        // config\r\n                        @(*vault, "contractConfig", payload.get("contractId"))!(\r\n                          payload.set("locked", false).set("counter", 1).set("version", "${e}").set("fee", payload.get("fee"))\r\n                        ) |\r\n\r\n                        new superKeyCh in {\r\n                          // return the bundle+ super key\r\n                          @return!((true, bundle+{*superKeyCh})) |\r\n\r\n                          for (@("LOCK", return2) <= superKeyCh) {\r\n                            for (@contractConfig <<- @(*vault, "contractConfig", payload.get("contractId"))) {\r\n                              if (contractConfig.get("locked") == true) {\r\n                                @return2!("error: contract is already locked")\r\n                              } else {\r\n                                for (_ <- @(*vault, "contractConfig", payload.get("contractId"))) {\r\n                                  @(*vault, "contractConfig", payload.get("contractId"))!(contractConfig.set("locked", true)) |\r\n                                  @return2!((true, Nil))\r\n                                }\r\n                              }\r\n                            }\r\n                          } |\r\n\r\n                          for (@("CREATE_PURSES", createPursesPayload, return2) <= superKeyCh) {\r\n                            for (@contractConfig <<- @(*vault, "contractConfig", payload.get("contractId"))) {\r\n                              if (contractConfig.get("locked") == true) {\r\n                                @return2!("error: contract is locked")\r\n                              } else {\r\n                                createPursesCh!((createPursesPayload, payload.get("contractId"), return2))\r\n                              }\r\n                            }\r\n                          }\r\n                        }\r\n                      }\r\n                    } else {\r\n                      @return!("error: contract id already exists")\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n              _ => {\r\n                @return!("error: invalid contract id")\r\n              }\r\n            }\r\n          }\r\n          _ => {\r\n            @return!("error: invalid payload")\r\n          }\r\n        }\r\n      } |\r\n\r\n\r\n      for (@("UPDATE_PURSE_PRICE", payload2, return2) <= @boxCh) {\r\n        new ch3, ch4, ch5 in {\r\n          match payload2 {\r\n            { "price": Int \\/ Nil, "contractId": String, "purseId": String } => {\r\n              getBoxCh!((boxId, *ch3)) |\r\n              for (@box <- ch3) {\r\n                if (box != Nil) {\r\n                  getPurseCh!((box, payload2.get("contractId"), payload2.get("purseId"), *ch4)) |\r\n                  for (@purse <- ch4) {\r\n                    if (purse != Nil) {\r\n                      for (@pursesThm <<- @(*vault, "purses", payload2.get("contractId"))) {\r\n                        TreeHashMap!("set", pursesThm, payload2.get("purseId"), purse.set("price", payload2.get("price")), *ch5) |\r\n                        for (_ <- ch5) {\r\n                          @return2!((true, Nil))\r\n                        }\r\n                      }\r\n                    } else {\r\n                      @return2!("error: purse not found")\r\n                    }\r\n                  }\r\n                } else {\r\n                  @return2!("error: CRITICAL box not found")\r\n                }\r\n              }\r\n            }\r\n            _ => {\r\n              @return2!("error: invalid payload for update price")\r\n            }\r\n          }\r\n        }\r\n      } |\r\n\r\n      for (@("UPDATE_PURSE_DATA", payload2, return2) <= @boxCh) {\r\n        new ch3, ch4, ch5 in {\r\n          match payload2 {\r\n            { "data": _, "contractId": String, "purseId": String } => {\r\n              getBoxCh!((boxId, *ch3)) |\r\n              for (@box <- ch3) {\r\n                if (box != Nil) {\r\n                  getPurseCh!((box, payload2.get("contractId"), payload2.get("purseId"), *ch4)) |\r\n                  for (@purse <- ch4) {\r\n                    if (box != Nil) {\r\n                      for (@pursesDataThm <<- @(*vault, "pursesData", payload2.get("contractId"))) {\r\n                        TreeHashMap!("set", pursesDataThm, payload2.get("purseId"), payload2.get("data"), *ch5) |\r\n                        for (_ <- ch5) {\r\n                          @return2!((true, Nil))\r\n                        }\r\n                      }\r\n                    } else {\r\n                       @return2!("error: purse not found")\r\n                    }\r\n                  }\r\n                } else {\r\n                  @return2!("error: CRITICAL box not found")\r\n                }\r\n              }\r\n            }\r\n            _ => {\r\n              @return2!("error: invalid payload for update data")\r\n            }\r\n          }\r\n        }\r\n      } |\r\n\r\n      for (@("WITHDRAW", payload2, return2) <= @boxCh) {\r\n        new ch3, ch4, ch5, ch6, ch7, ch8, ch9, ch10, ch11, proceedWithdrawCh, mergeCh, mergeOkCh in {\r\n          match payload2 {\r\n            { "quantity": Int, "contractId": String, "purseId": String, "toBoxId": String, "merge": Bool } => {\r\n              getContractPursesThmCh!((payload2.get("contractId"), *ch4)) |\r\n              getBoxCh!((payload2.get("toBoxId"), *ch6)) |\r\n              getBoxCh!((boxId, *ch10)) |\r\n              for (@pursesThm <- ch4; @toBox <- ch6; @box <- ch10) {\r\n                match (pursesThm != Nil, toBox != Nil, box != Nil) {\r\n                  (true, true, true) => {\r\n                    getPurseCh!((box, payload2.get("contractId"), payload2.get("purseId"), *ch9)) |\r\n                    for (@purse <- ch9) {\r\n                      if (purse == Nil) {\r\n                        @return2!("error: purse does not exist")\r\n                      } else {\r\n                        if (purse.get("id") != "0") {\r\n                          proceedWithdrawCh!((pursesThm, purse))\r\n                        } else {\r\n                          @return2!("error: withdraw from special nft 0 is forbidden")\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n                  _ => {\r\n                    @return2!("error: contract or recipient box does not exist")\r\n                  }\r\n                }\r\n              }\r\n            }\r\n            _ => {\r\n              @return2!("error: invalid payload for withdraw")\r\n            }\r\n          } |\r\n\r\n          for (@(pursesThm, purse) <- proceedWithdrawCh) {\r\n\r\n            // the withdrawer should not be able to choose if\r\n            // tokens in recipient box will or will not be \r\n            // merged, except if he withdraws to himself\r\n            mergeCh!(payload2.get("merge")) |\r\n            if (payload2.get("toBoxId") != boxId) {\r\n              for (_ <- mergeCh) {\r\n                mergeOkCh!(true)\r\n              }\r\n            } else {\r\n              for (@m <- mergeCh) {\r\n                mergeOkCh!(m)\r\n              }\r\n            } |\r\n\r\n            for (@merge <- mergeOkCh) {\r\n              match (\r\n                purse.get("quantity") - payload2.get("quantity") >= 0,\r\n                purse.get("quantity") > 0,\r\n                purse.get("quantity") - payload2.get("quantity") > 0\r\n              ) {\r\n\r\n                // ajust quantity in first purse, create a second purse\r\n                // associated with toBoxId\r\n                (true, true, true) => {\r\n                  TreeHashMap!("set", pursesThm, payload2.get("purseId"), purse.set("quantity", purse.get("quantity") - payload2.get("quantity")),  *ch5) |\r\n                  for (_ <- ch5) {\r\n                    makePurseCh!((\r\n                      payload2.get("contractId"),\r\n                      purse\r\n                        .set("price", Nil)\r\n                        .set("quantity", payload2.get("quantity"))\r\n                        .set("boxId", payload2.get("toBoxId")),\r\n                      Nil,\r\n                      merge,\r\n                      return2\r\n                    ))\r\n                  }\r\n                }\r\n\r\n                // remove first purse, create a second purse\r\n                // associated with toBoxId\r\n                (true, true, false) => {\r\n                  TreeHashMap!("set", pursesThm, payload2.get("purseId"), Nil,  *ch5) |\r\n                  for (@pursesDataThm <<- @(*vault, "pursesData", payload2.get("contractId"))) {\r\n                    TreeHashMap!(\r\n                      "get",\r\n                      pursesDataThm,\r\n                      payload2.get("purseId"),\r\n                      *ch7\r\n                    ) |\r\n                    for (_ <- ch5; @data <- ch7) {\r\n                      TreeHashMap!(\r\n                        "set",\r\n                        pursesDataThm,\r\n                        payload2.get("purseId"),\r\n                        Nil,\r\n                        *ch11\r\n                      ) |\r\n                      for (_ <- ch11) {\r\n                        removePurseInBoxCh!((boxId, payload2.get("contractId"), payload2.get("purseId"), *ch8)) |\r\n                        for (@r <- ch8) {\r\n                          match r {\r\n                            String => {\r\n                              @return2!(r)\r\n                            }\r\n                            _ => {\r\n                              makePurseCh!((\r\n                                payload2.get("contractId"),\r\n                                purse\r\n                                  .set("price", Nil)\r\n                                  .set("boxId", payload2.get("toBoxId")),\r\n                                data,\r\n                                merge,\r\n                                return2\r\n                              )) \r\n                            }\r\n                          }\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n                _ => {\r\n                  @return2!("error: cannot withdraw, quantity in payload is superior to existing purse quantity")\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      } |\r\n\r\n      for (@(amount, contractConfig, return2) <= calculateFeeCh) {\r\n        if (contractConfig.get("fee") == Nil) {\r\n          @return2!((amount, 0, Nil))\r\n        } else {\r\n          match amount * contractConfig.get("fee").nth(1) / 100000 {\r\n            feeAmount => {\r\n              @return2!((amount - feeAmount, feeAmount, contractConfig.get("fee").nth(0)))\r\n            }\r\n          }\r\n        }\r\n      } |\r\n\r\n      for (@("PURCHASE", payload2, return2) <= @boxCh) {\r\n        match payload2 {\r\n          { "quantity": Int, "contractId": String, "merge": Bool, "purseId": String, "newId": Nil \\/ String, "data": _, "purseRevAddr": _, "purseAuthKey": _ } => {\r\n            new ch3, ch4, ch5, ch6, ch7, step2Ch, ch20, ch21, ch22, ch23, ch24, ch25, ch26, ch27, ch28, step3Ch, rollbackCh, ch30, ch31, ch32, ch33, ch34, ch35, ch36, ch37, step4Ch, ch40, ch41, ch42, ch43, ch44, ch45, ch46, ch47, ch48, step5Ch, ch50, ch51, ch52, ch53 in {\r\n\r\n              // STEP 1\r\n              // check box, purse\r\n              getBoxCh!((boxId, *ch3)) |\r\n              for (@box <- ch3) {\r\n                if (box != Nil) {\r\n                  getContractPursesThmCh!((payload2.get("contractId"), *ch4)) |\r\n                  getContractPursesDataThmCh!((payload2.get("contractId"), *ch5)) |\r\n                  for (@pursesThm <- ch4; @pursesDataThm <- ch5) {\r\n                    if (pursesThm != Nil) {\r\n                      TreeHashMap!("get", pursesThm, payload2.get("purseId"), *ch6) |\r\n                      TreeHashMap!("get", pursesDataThm, payload2.get("purseId"), *ch7)\r\n                    } else {\r\n                      @return2!("error: contract not found")\r\n                    } |\r\n                    for (@purse <- ch6; @purseData <- ch7) {\r\n                      if (purse != Nil) {\r\n                        step2Ch!((pursesThm, pursesDataThm, purse, purseData))\r\n                      } else {\r\n                        @return2!("error: purse not found")\r\n                      }\r\n                    }\r\n                  }\r\n                } else {\r\n                  @return2!("error: CRITICAL box not found")\r\n                }\r\n              } |\r\n\r\n              // STEP 2\r\n              // transfer total amount to temporary escrow purse\r\n              // check that both emitter and recipient vault exist\r\n              for (@(pursesThm, pursesDataThm, purse, purseData) <- step2Ch) {\r\n                match (\r\n                  purse.get("price"),\r\n                  purse.get("quantity") > 0,\r\n                  payload2.get("quantity") > 0,\r\n                  purse.get("quantity") >= payload2.get("quantity")\r\n                ) {\r\n                  (Int, true, true, true) => {\r\n                    registryLookup!(\`rho:rchain:revVault\`, *ch20) |\r\n\r\n                    for (@boxConfig <<- @(*vault, "boxConfig", purse.get("boxId"))) {\r\n                      revAddress!("fromPublicKey", boxConfig.get("publicKey").hexToBytes(), *ch21)\r\n                    } |\r\n\r\n                    for (@contractConfig <<- @(*vault, "contractConfig", payload2.get("contractId"))) {\r\n                      calculateFeeCh!((payload2.get("quantity") * purse.get("price"), contractConfig, *ch22))\r\n                    } |\r\n\r\n                    for (@(_, RevVault) <- ch20; @ownerRevAddress <- ch21; @amountAndFeeAmount <- ch22) {\r\n                      match (\r\n                        payload2.get("purseRevAddr"),\r\n                        ownerRevAddress,\r\n                        amountAndFeeAmount.nth(0),\r\n                        amountAndFeeAmount.nth(1),\r\n                        amountAndFeeAmount.nth(2)\r\n                      ) {\r\n                        (emitterRevAddress, recipientRevAddress, amount, feeAmount, feePublicKey) => {\r\n                          @RevVault!("findOrCreate", emitterRevAddress, *ch23) |\r\n                          @RevVault!("findOrCreate", recipientRevAddress, *ch24) |\r\n                          for (@a <- ch23; @b <- ch24) {\r\n                            match (a, b) {\r\n                              ((true, purseVaultEmitter),  (true, purseVaultRecipient)) => {\r\n                                new unf in {\r\n                                  @RevVault!("unforgeableAuthKey", *unf, *ch25) |\r\n                                  revAddress!("fromUnforgeable", *unf, *ch26) |\r\n                                  for (@escrowPurseAuthKey <- ch25; @escrowPurseRevAddr <- ch26) {\r\n                                    @RevVault!("findOrCreate", escrowPurseRevAddr, *ch27) |\r\n                                    for (@(true, escrowPurseVault) <- ch27) {\r\n                                      @purseVaultEmitter!("transfer", escrowPurseRevAddr, amount + feeAmount, payload2.get("purseAuthKey"), *ch28) |\r\n                                      for (@escrowTransferResult <- ch28) {\r\n                                        match escrowTransferResult {\r\n                                          (true, Nil) => {\r\n                                            stdout!("transfer to escrow purse successful") |\r\n                                            step3Ch!((pursesThm, pursesDataThm, purse, purseData, RevVault, escrowPurseRevAddr, escrowPurseAuthKey, emitterRevAddress, recipientRevAddress, amount, feeAmount, feePublicKey))\r\n                                          }\r\n                                          _ => {\r\n                                            stdout!(escrowTransferResult) |\r\n                                            @return2!("error: escrow transfer went wrong, invalid rev purse in payload")\r\n                                          }\r\n                                        }\r\n                                      }\r\n                                    }\r\n                                  }\r\n                                }\r\n                              }\r\n                              _ => {\r\n                                @return2!("error: could not find or create vaults")\r\n                              }\r\n                            }\r\n                          }\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n                  _ => {\r\n                    @return2!("error: quantity not available or purse not for sale")\r\n                  }\r\n                }\r\n              } |\r\n\r\n              // STEP 3\r\n              // listen on rollbackCh and prepare to reset state to original\r\n              // if step 4 or 5 fails\r\n              // \r\n              for (@(pursesThm, pursesDataThm, purse, purseData, RevVault, escrowPurseRevAddr, escrowPurseAuthKey, emitterRevAddress, recipientRevAddress, amount, feeAmount, feePublicKey) <- step3Ch) {\r\n                for (@message <- rollbackCh) {\r\n                  TreeHashMap!("set", pursesThm, purse.get("id"), purse,  *ch30) |\r\n                  TreeHashMap!("set", pursesDataThm, purse.get("id"), purseData,  *ch31) |\r\n                  if (purse.get("quantity") - payload2.get("quantity") == 0) {\r\n                    savePurseInBoxCh!((payload2.get("contractId"), purse.get("boxId"), purse.get("id"), true, *ch32))\r\n                  } else {\r\n                    // the purse has not been removed from box\r\n                    ch32!((true, Nil))\r\n                  } |\r\n                  for (_ <- ch30; _ <- ch31; @a <- ch32) {\r\n                    match a {\r\n                      String => {\r\n                        stdout!("error: CRITICAL could not rollback after makePurse error") |\r\n                        @return2!("error: CRITICAL could not rollback after makePurse error")\r\n                      }\r\n                      _ => {\r\n                        @RevVault!("findOrCreate", escrowPurseRevAddr, *ch33) |\r\n                        for (@(true, purseVaultEscrow) <- ch33) {\r\n                          @purseVaultEscrow!("transfer", emitterRevAddress, amount + feeAmount, escrowPurseAuthKey, *ch34) |\r\n                          for (@r <- ch34) {\r\n                            match r {\r\n                              (true, Nil) => {\r\n                                @return2!("error: rollback successful, makePurse error, transaction was rolled backed, emitter purse was reimbursed " ++ message)\r\n                              }\r\n                              _ => {\r\n                                stdout!(r) |\r\n                                stdout!("error: CRITICAL, makePurse error, could rollback but could not reimburse after makePurse error" ++ message) |\r\n                                @return2!("error: CRITICAL, makePurse error, could rollback but could not reimburse after makePurse error" ++ message)\r\n                              }\r\n                            }\r\n                          }\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n                } |\r\n                step4Ch!((pursesThm, pursesDataThm, purse, purseData, RevVault, escrowPurseRevAddr, escrowPurseAuthKey, emitterRevAddress, recipientRevAddress, amount, feeAmount, feePublicKey))\r\n              } |\r\n\r\n              // STEP 4\r\n              // try to makePurse\r\n              for (@(pursesThm, pursesDataThm, purse, purseData, RevVault, escrowPurseRevAddr, escrowPurseAuthKey, emitterRevAddress, recipientRevAddress, amount, feeAmount, feePublicKey) <- step4Ch) {\r\n                for (@makePurseResult <- ch43) {\r\n                  match makePurseResult {\r\n                    String => {\r\n                      rollbackCh!(makePurseResult)\r\n                    }\r\n                    _ => {\r\n                      step5Ch!((pursesThm, pursesDataThm, purse, purseData, RevVault, escrowPurseRevAddr, escrowPurseAuthKey, emitterRevAddress, recipientRevAddress, amount, feeAmount, feePublicKey))\r\n                    }\r\n                  }\r\n                } |\r\n\r\n                // remove completely purse and create a new one\r\n                // with same id, id may be changed by makePurse\r\n                // depending on fungible or not\r\n                if (purse.get("quantity") - payload2.get("quantity") == 0) {\r\n                  TreeHashMap!("set", pursesThm, purse.get("id"), Nil,  *ch40) |\r\n                  TreeHashMap!("set", pursesDataThm, purse.get("id"), Nil,  *ch41) |\r\n                  removePurseInBoxCh!((purse.get("boxId"), payload2.get("contractId"), purse.get("id"), *ch42)) |\r\n\r\n                  for (_ <- ch40; _ <- ch41; _ <- ch42) {\r\n                    makePurseCh!((\r\n                      payload2.get("contractId"),\r\n                      // keep quantity and type of existing purse\r\n                      purse\r\n                        .set("boxId", boxId)\r\n                        .set("price", Nil)\r\n                        // will only considered for nft, purchase from purse "0"\r\n                        .set("newId", payload2.get("newId")),\r\n                      payload2.get("data"),\r\n                      payload2.get("merge"),\r\n                      *ch43\r\n                    ))\r\n                  }\r\n                } else {\r\n                  // just update quantity of current purse, and\r\n                  //  create another one with right quantity\r\n                  TreeHashMap!("set", pursesThm, purse.get("id"), purse.set("quantity", purse.get("quantity") - payload2.get("quantity")),  *ch40) |\r\n\r\n                  for (_ <- ch40) {\r\n                    makePurseCh!((\r\n                      payload2.get("contractId"),\r\n                      purse\r\n                        .set("boxId", boxId)\r\n                        .set("quantity", payload2.get("quantity"))\r\n                        .set("price", Nil)\r\n                        // will only considered for nft, purchase from purse "0"\r\n                        .set("newId", payload2.get("newId")),\r\n                      payload2.get("data"),\r\n                      payload2.get("merge"),\r\n                      *ch43\r\n                    ))\r\n                  }\r\n                }\r\n              } |\r\n\r\n              // STEP 5\r\n              // everything went ok, do final payment\r\n              for (@(pursesThm, pursesDataThm, purse, purseData, RevVault, escrowPurseRevAddr, escrowPurseAuthKey, emitterRevAddress, recipientRevAddress, amount, feeAmount, feePublicKey) <- step5Ch) {\r\n                @RevVault!("findOrCreate", escrowPurseRevAddr, *ch50) |\r\n                for (@(true, purseVaultEscrow) <- ch50) {\r\n                  @purseVaultEscrow!("transfer", recipientRevAddress, amount, escrowPurseAuthKey, *ch51) |\r\n                  for (@r <- ch51) {\r\n                    match r {\r\n                      (true, Nil) => {\r\n                        if (feeAmount != 0) {\r\n                          revAddress!("fromPublicKey", feePublicKey.hexToBytes(), *ch52) |\r\n                          for (@feeRevAddress <- ch52) {\r\n                            @purseVaultEscrow!("transfer", feeRevAddress, feeAmount, escrowPurseAuthKey, *ch53)\r\n                          } |\r\n                          for (@transferFeeReturn <- ch53) {\r\n                            match transferFeeReturn {\r\n                              (true, Nil) => {\r\n                                stdout!("fee transfer successful")\r\n                              }\r\n                              _ => {\r\n                                stdout!("error: CRITICAL could not transfer fee")\r\n                              }\r\n                            }\r\n                          }\r\n                        } |\r\n                        @return2!((true, Nil))\r\n                      }\r\n                      _ => {\r\n                        stdout!("error: CRITICAL, makePurse went fine, but could not do final transfer") |\r\n                        rollbackCh!("error: CRITICAL, makePurse went fine, but could not do final transfer")\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n          _ => {\r\n            @return2!("error: invalid payload")\r\n          }\r\n        }\r\n      }\r\n    } |\r\n\r\n\r\n\r\n    /* ###################################################################################### */\r\n    /*                             register public entry channel                              */\r\n    insertArbitrary!(bundle+{*entryCh}, *entryUriCh) |\r\n\r\n    for (entryUri <- entryUriCh) {\r\n      basket!({\r\n        "status": "completed",\r\n        "registryUri": *entryUri\r\n      }) |\r\n        stdout!({"uri": *entryUri})\r\n    }\r\n  } |\r\n\r\n  \r\n  /*##########################################################################################*/\r\n  /*                             TreeHashMap (reimplementation)                               */\r\n  // Communications between channels have generally been reduced to reduce amount of\r\n  // serialization / deserialization\r\n\r\n  // when you "init" you can choose that the processes are also stored as bytes, instead of storing a map for each node, it stores a map at channel @map, and bytes at channel @(map, "bytes), this will make the "getAllValues" 10x, 20x, 30x faster depending on the process you are storing\r\n\r\n  // !!! make sure your processes do not contain the string "£$£$", or the bytes c2a324c2a324, those are used as delimiters\r\n\r\n  // depth 1 = 12 maps in tree hash map\r\n  // depth 2 = 12 * 12 = 144 maps in tree hash map\r\n  // etc...\r\n\r\n  TreeHashMap!("init", "${t}", true, *boxesReadyCh) |\r\n  TreeHashMap!("init", "${t}", false, *contractsReadyCh) |\r\n\r\n  new MakeNode, ByteArrayToNybbleList, TreeHashMapSetter, TreeHashMapGetter, HowManyPrefixes, NybbleListForI, RemoveBytesSectionIfExistsCh, keccak256Hash(\`rho:crypto:keccak256Hash\`), powersCh, storeToken, nodeGet in {\r\n    match ([1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,655256], ["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"], 12) {\r\n      (powers, hexas, base) => {\r\n        contract MakeNode(@initVal, @node) = {\r\n          @[node, *storeToken]!(initVal)\r\n        } |\r\n\r\n        contract nodeGet(@node, ret) = {\r\n          for (@val <<- @[node, *storeToken]) {\r\n            ret!(val)\r\n          }\r\n        } |\r\n\r\n        contract HowManyPrefixes(@map, ret) = {\r\n          for (@depth <<- @(map, "depth")) {\r\n            match depth {\r\n              1 => ret!(base)\r\n              2 => ret!(base * base)\r\n              3 => ret!(base * base * base)\r\n              4 => ret!(base * base * base * base)\r\n            }\r\n          }\r\n        } |\r\n\r\n        contract NybbleListForI(@map, @i, @depth, ret) = {\r\n          match depth {\r\n            1 => {\r\n              match hexas.nth(i % base) {\r\n                str => {\r\n                  ByteArrayToNybbleList!(str.hexToBytes(), 0, depth, [], *ret)\r\n                }\r\n              }\r\n            }\r\n            2 => {\r\n              match hexas.nth(i / base) ++ hexas.nth(i % base) {\r\n                str => {\r\n                  ByteArrayToNybbleList!(str.hexToBytes(), 0, depth, [], *ret)\r\n                }\r\n              }\r\n            }\r\n            3 => {\r\n              match hexas.nth(i / base / base) ++ hexas.nth(i / base) ++ hexas.nth(i % base) {\r\n                str => {\r\n                  ByteArrayToNybbleList!(str.hexToBytes(), 0, depth, [], *ret)\r\n                }\r\n              }\r\n            }\r\n            4 => {\r\n              match hexas.nth(i / base / base / base) ++ hexas.nth(i / base / base) ++ hexas.nth(i / base) ++ hexas.nth(i % base) {\r\n                str => {\r\n                  ByteArrayToNybbleList!(str.hexToBytes(), 0, depth, [], *ret)\r\n                }\r\n              }\r\n            }\r\n          }\r\n        } |\r\n\r\n        contract ByteArrayToNybbleList(@ba, @n, @len, @acc, ret) = {\r\n          if (n == len) {\r\n            ret!(acc)\r\n          } else {\r\n            ByteArrayToNybbleList!(ba, n+1, len, acc ++ [ ba.nth(n) % base ], *ret)\r\n          }\r\n        } |\r\n\r\n        contract TreeHashMap(@"init", @depth, @alsoStoreAsBytes, ret) = {\r\n          new map in {\r\n            MakeNode!(0, (*map, [])) |\r\n            if (alsoStoreAsBytes == true) {\r\n              MakeNode!(0, ((*map, "bytes"), []))\r\n            } |\r\n            @(*map, "depth")!!(depth) |\r\n            @(*map, "alsoStoreAsBytes")!!(alsoStoreAsBytes) |\r\n            ret!(*map)\r\n          }\r\n        } |\r\n\r\n        contract TreeHashMapGetter(@map, @nybList, @n, @len, @suffix, ret) = {\r\n          // Look up the value of the node at (map, nybList.slice(0, n + 1))\r\n          for (@val <<- @[(map, nybList.slice(0, n)), *storeToken]) {\r\n            if (n == len) {\r\n              ret!(val.get(suffix))\r\n            } else {\r\n              // Otherwise check if the rest of the path exists.\r\n              // Bit k set means node k exists.\r\n              // nybList.nth(n) is the node number\r\n              // val & powers.nth(nybList.nth(n)) is nonzero if the node exists\r\n              // (val / powers.nth(nybList.nth(n))) % 2 is 1 if the node exists\r\n              if ((val / powers.nth(nybList.nth(n))) % 2 == 0) {\r\n                ret!(Nil)\r\n              } else {\r\n                TreeHashMapGetter!(map, nybList, n + 1, len, suffix, *ret)\r\n              }\r\n            }\r\n          }\r\n        } |\r\n\r\n        contract TreeHashMap(@"get", @map, @key, ret) = {\r\n          new hashCh, nybListCh in {\r\n            // Hash the key to get a 256-bit array\r\n            keccak256Hash!(key.toByteArray(), *hashCh) |\r\n            for (@hash <- hashCh) {\r\n              for (@depth <<- @(map, "depth")) {\r\n                // Get the bit list\r\n                ByteArrayToNybbleList!(hash, 0, depth, [], *nybListCh) |\r\n                for (@nybList <- nybListCh) {\r\n                  TreeHashMapGetter!(map, nybList, 0,  depth, hash.slice(depth, 32), *ret)\r\n                }\r\n              }\r\n            }\r\n          }\r\n        } |\r\n    \r\n        contract TreeHashMap(@"getAllValues", @map, ret) = {\r\n          new hashCh, resultCh, howManyPrefixesCh, iterateOnPrefixesCh, nybListCh in {\r\n            HowManyPrefixes!(map, *howManyPrefixesCh) |\r\n            for (@depth <<- @(map, "depth")) {\r\n              for (@alsoStoreAsBytes <<- @(map, "alsoStoreAsBytes")) {\r\n                for (@howManyPrefixes <- howManyPrefixesCh ) {\r\n                  contract iterateOnPrefixesCh() = {\r\n                    new itCh, bytesOrMapCh, TreeHashMapGetterValues in {\r\n                      // do not move it up, the goal is reduce the number of serializatin / dezerialization\r\n                      contract TreeHashMapGetterValues(@channel, @nybList, @n, @len, @i) = {\r\n                        // channel is either map or (map, "bytes")\r\n                        // Look up the value of the node at (channel, nybList.slice(0, n + 1))\r\n                        for (@val <<- @[(channel, nybList.slice(0, n)), *storeToken]) {\r\n                          if (n == len) {\r\n                            if (val == Nil) {\r\n                              itCh!(i + 1)\r\n                            } else {\r\n                              if (alsoStoreAsBytes == true) {\r\n                                for (@bytes <- bytesOrMapCh) {\r\n                                  itCh!(i + 1) |\r\n                                  // store-as-bytes-map\r\n                                  bytesOrMapCh!(bytes.union(val))\r\n                                  // store-as-bytes-array\r\n                                //   if (bytes == Nil) {\r\n                                //     bytesOrMapCh!(bytes)\r\n                                //   } else {\r\n                                //     bytesOrMapCh!(bytes ++ val)\r\n                                //   }\r\n                                }\r\n                              } else {\r\n                                for (@map <- bytesOrMapCh) {\r\n                                  bytesOrMapCh!(map.union(val)) |\r\n                                  itCh!(i + 1)\r\n                                }\r\n                              }\r\n                            }\r\n                          } else {\r\n                            // Otherwise check if the rest of the path exists.\r\n                            // Bit k set means node k exists.\r\n                            // nybList.nth(n) is the node number\r\n                            // val & powers.nth(nybList.nth(n)) is nonzero if the node exists\r\n                            // (val / powers.nth(nybList.nth(n))) % 2 is 1 if the node exists\r\n                            if ((val / powers.nth(nybList.nth(n))) % 2 == 0) {\r\n                              itCh!(i + 1)\r\n                            } else {\r\n                              TreeHashMapGetterValues!(channel, nybList, n + 1, len, i)\r\n                            }\r\n                          }\r\n                        }\r\n                      } |\r\n\r\n                      for (@i <= itCh) {\r\n                        match i <= howManyPrefixes - 1 {\r\n                          false => {\r\n                            for (@a <- bytesOrMapCh) {\r\n                              ret!(a)\r\n                            }\r\n                          }\r\n                          true => {\r\n                            NybbleListForI!(map, i, depth, *nybListCh) |\r\n                            for (@nybList <- nybListCh) {\r\n                              if (alsoStoreAsBytes == true) {\r\n                                TreeHashMapGetterValues!((map, "bytes"), nybList, 0, depth, i)\r\n                              } else {\r\n                                TreeHashMapGetterValues!(map, nybList, 0, depth, i)\r\n                              }\r\n                            }\r\n                          }\r\n                        }\r\n                      } |\r\n                      if (alsoStoreAsBytes == true) {\r\n                        // store-as-bytes-map\r\n                        bytesOrMapCh!({})\r\n                        // store-as-bytes-array\r\n                        /* bytesOrMapCh!(Nil) */\r\n                      } else {\r\n                        bytesOrMapCh!({})\r\n                      } |\r\n                      itCh!(0)\r\n                    }\r\n                  } |\r\n\r\n                  iterateOnPrefixesCh!()\r\n                }\r\n              }\r\n            }\r\n          }\r\n        } |\r\n\r\n        contract TreeHashMapSetter(@channel, @nybList, @n, @len, @newVal, @suffix, ret) = {\r\n          // channel is either map or (map, "bytes")\r\n          // Look up the value of the node at (channel, nybList.slice(0, n + 1))\r\n          new valCh, restCh in {\r\n            match (channel, nybList.slice(0, n)) {\r\n              node => {\r\n                for (@val <<- @[node, *storeToken]) {\r\n                  if (n == len) {\r\n                    // Acquire the lock on this node\r\n                    for (@val <- @[node, *storeToken]) {\r\n                      // If we're at the end of the path, set the node to newVal.\r\n                      if (val == 0) {\r\n                        // Release the lock\r\n                        @[node, *storeToken]!({suffix: newVal}) |\r\n                        // Return\r\n                        ret!(Nil)\r\n                      }\r\n                      else {\r\n                        // Release the lock\r\n                        if (newVal == Nil) {\r\n                          @[node, *storeToken]!(val.delete(suffix)) |\r\n                          // Return\r\n                          ret!(Nil)\r\n                        } else {\r\n                          @[node, *storeToken]!(val.set(suffix, newVal)) |\r\n                          // Return\r\n                          ret!(Nil)\r\n                        }\r\n                      }\r\n                    }\r\n                  } else {\r\n                    // Otherwise make the rest of the path exist.\r\n                    // Bit k set means child node k exists.\r\n                    if ((val/powers.nth(nybList.nth(n))) % 2 == 0) {\r\n                      // Child node missing\r\n                      // Acquire the lock\r\n                      for (@val <- @[node, *storeToken]) {\r\n                        // Re-test value\r\n                        if ((val/powers.nth(nybList.nth(n))) % 2 == 0) {\r\n                          // Child node still missing\r\n                          // Create node, set node to 0\r\n                          MakeNode!(0, (channel, nybList.slice(0, n + 1))) |\r\n                          // Update current node to val | (1 << nybList.nth(n))\r\n                          match nybList.nth(n) {\r\n                            bit => {\r\n                              // val | (1 << bit)\r\n                              // Bitwise operators would be really nice to have!\r\n                              // Release the lock\r\n                              @[node, *storeToken]!((val % powers.nth(bit)) +\r\n                                (val / powers.nth(bit + 1)) * powers.nth(bit + 1) +\r\n                                powers.nth(bit))\r\n                            }\r\n                          } |\r\n                          // Child node now exists, loop\r\n                          TreeHashMapSetter!(channel, nybList, n + 1, len, newVal, suffix, *ret)\r\n                        } else {\r\n                          // Child node created between reads\r\n                          // Release lock\r\n                          @[node, *storeToken]!(val) |\r\n                          // Loop\r\n                          TreeHashMapSetter!(channel, nybList, n + 1, len, newVal, suffix, *ret)\r\n                        }\r\n                      }\r\n                    } else {\r\n                      // Child node exists, loop\r\n                      TreeHashMapSetter!(channel, nybList, n + 1, len, newVal, suffix, *ret)\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        } |\r\n\r\n        contract TreeHashMap(@"set", @map, @key, @newVal, ret) = {\r\n          new hashCh, nybListCh in {\r\n            // Hash the key to get a 256-bit array\r\n            keccak256Hash!(key.toByteArray(), *hashCh) |\r\n            for (@hash <- hashCh) {\r\n              for (@depth <<- @(map, "depth")) {\r\n                for (@alsoStoreAsBytes <<- @(map, "alsoStoreAsBytes")) {\r\n                  ByteArrayToNybbleList!(hash, 0, depth, [], *nybListCh) |\r\n                  // Get the bit list\r\n                  for (@nybList <- nybListCh) {\r\n                    if (alsoStoreAsBytes == true) {\r\n                      new ret1, ret2 in {\r\n                        if (newVal == Nil) {\r\n                          TreeHashMapSetter!((map, "bytes"), nybList, 0,  depth, Nil, hash.slice(depth, 32), *ret2)\r\n                        } else {\r\n                          TreeHashMapSetter!((map, "bytes"), nybList, 0,  depth, newVal.toByteArray(), hash.slice(depth, 32), *ret2)\r\n                        } |\r\n                        TreeHashMapSetter!(map, nybList, 0, depth, newVal, hash.slice(depth, 32), *ret1) |\r\n                        for (_ <- ret1; _ <- ret2) {\r\n                          ret!(Nil)\r\n                        }\r\n                      }\r\n                    } else {\r\n                      TreeHashMapSetter!(map, nybList, 0,  depth, newVal, hash.slice(depth, 32), *ret)\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  } \r\n}\r\n`,r.op_create_purses=({})=>'new basket,\r\n  returnCh,\r\n  boxCh,\r\n  stdout(`rho:io:stdout`),\r\n  deployerId(`rho:rchain:deployerId`),\r\n  registryLookup(`rho:registry:lookup`)\r\nin {\r\n\r\n  for (superKey <<- @(*deployerId, "rchain-token-contract", "MASTER_REGISTRY_URI", "CONTRACT_ID")) {\r\n    superKey!((\r\n      "CREATE_PURSES",\r\n      {\r\n        // example\r\n        // "purses": { "0": { "box": "abc", "type": "gold", "quantity": 3, "data": Nil }}\r\n        "purses": CREATE_PURSESS,\r\n        // example\r\n        // "data": { "0": "this bag is mine" }\r\n        "data": CREATE_PURSESS_DATA,\r\n      },\r\n      *returnCh\r\n    )) |\r\n    for (@r <- returnCh) {\r\n      match r {\r\n        String => {\r\n          basket!({ "status": "failed", "message": r }) |\r\n          stdout!(("failed", r))\r\n        }\r\n        _ => {\r\n          stdout!("completed, purses created and saved to box") |\r\n          basket!({ "status": "completed" })\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n',r.op_deploy=({})=>'new basket,\r\n  masterEntryCh,\r\n  registerContractReturnCh,\r\n  sendReturnCh,\r\n  deletePurseReturnCh,\r\n  boxCh,\r\n  stdout(`rho:io:stdout`),\r\n  deployerId(`rho:rchain:deployerId`),\r\n  registryLookup(`rho:registry:lookup`)\r\nin {\r\n\r\n  registryLookup!(`rho:id:MASTER_REGISTRY_URI`, *masterEntryCh) |\r\n\r\n  for (boxCh <<- @(*deployerId, "rchain-token-box", "MASTER_REGISTRY_URI", "BOX_ID")) {\r\n    boxCh!(("PUBLIC_REGISTER_CONTRACT", { "contractId": "CONTRACT_ID", "fungible": FUNGIBLE, "fee": FEE }, *registerContractReturnCh)) |\r\n    for (@r <- registerContractReturnCh) {\r\n      match r {\r\n        String => {\r\n          basket!({ "status": "failed", "message": r }) |\r\n          stdout!(("failed", r))\r\n        }\r\n        (true, superKey) => {\r\n          @(*deployerId, "rchain-token-contract", "MASTER_REGISTRY_URI", "CONTRACT_ID")!(superKey) |\r\n          basket!({\r\n            "status": "completed",\r\n            "masterRegistryUri": "MASTER_REGISTRY_URI",\r\n            "contractId": "CONTRACT_ID",\r\n          }) |\r\n          stdout!("completed, contract registered")\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n',r.op_deploy_box=({})=>'new basket,\r\n  masterEntryCh,\r\n  registerBoxReturnCh,\r\n  sendReturnCh,\r\n  deletePurseReturnCh,\r\n  boxCh,\r\n  stdout(`rho:io:stdout`),\r\n  deployerId(`rho:rchain:deployerId`),\r\n  registryLookup(`rho:registry:lookup`)\r\nin {\r\n\r\n  registryLookup!(`rho:id:MASTER_REGISTRY_URI`, *masterEntryCh) |\r\n\r\n  for (masterEntry <- masterEntryCh) {\r\n    masterEntry!(("PUBLIC_REGISTER_BOX", { "boxId": "BOX_ID", "publicKey": "PUBLIC_KEY" }, *registerBoxReturnCh)) |\r\n    for (@r <- registerBoxReturnCh) {\r\n      match r {\r\n        String => {\r\n          basket!({ "status": "failed", "message": r }) |\r\n          stdout!(("failed", r))\r\n        }\r\n        (true, box) => {\r\n          @(*deployerId, "rchain-token-box", "MASTER_REGISTRY_URI", "BOX_ID")!(box) |\r\n          basket!({ "status": "completed", "boxId": "BOX_ID" }) |\r\n          stdout!("completed, box registered")\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n',r.op_lock=({})=>'new basket,\r\n  returnCh,\r\n  stdout(`rho:io:stdout`),\r\n  deployerId(`rho:rchain:deployerId`),\r\n  registryLookup(`rho:registry:lookup`)\r\nin {\r\n\r\n\r\n  for (superKey <<- @(*deployerId, "rchain-token-contract", "MASTER_REGISTRY_URI", "CONTRACT_ID")) {\r\n    superKey!((\r\n      "LOCK",\r\n      *returnCh\r\n    )) |\r\n    for (@r <- returnCh) {\r\n      match r {\r\n        String => {\r\n          basket!({ "status": "failed", "message": r }) |\r\n          stdout!(("failed", r))\r\n        }\r\n        _ => {\r\n          stdout!("completed, contract locked") |\r\n          basket!({ "status": "completed" })\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n',r.op_purchase=({})=>`\r\nnew\r\n  basket,\r\n  revVaultCh,\r\n  boxCh,\r\n\r\n  returnCh,\r\n  quantityCh,\r\n  mergeCh,\r\n  publicKeyCh,\r\n  priceCh,\r\n  newIdCh,\r\n  dataCh,\r\n  purseIdCh,\r\n  contractIdCh,\r\n\r\n  revAddressCh,\r\n  contractExistsCh,\r\n  proceed1Ch,\r\n  proceed2Ch,\r\n  registryLookup(\`rho:registry:lookup\`),\r\n  deployerId(\`rho:rchain:deployerId\`),\r\n  stdout(\`rho:io:stdout\`),\r\n  revAddress(\`rho:rev:address\`)\r\nin {\r\n\r\n  purseIdCh!!("PURSE_ID") |\r\n  contractIdCh!!("CONTRACT_ID") |\r\n  newIdCh!!("NEW_ID") |\r\n  priceCh!!(PRICEE) |\r\n  mergeCh!!(MERGE) |\r\n  quantityCh!!(QUANTITY) |\r\n  publicKeyCh!!("PUBLIC_KEY") |\r\n  dataCh!!("PURCHASE_PURSE_DATA") |\r\n\r\n  for (boxCh <<- @(*deployerId, "rchain-token-box", "MASTER_REGISTRY_URI", "BOX_ID")) {\r\n\r\n    registryLookup!(\`rho:id:MASTER_REGISTRY_URI\`, *contractExistsCh) |\r\n    for (_ <- contractExistsCh) {\r\n      proceed1Ch!(Nil)\r\n    } |\r\n\r\n    registryLookup!(\`rho:rchain:revVault\`, *revVaultCh) |\r\n\r\n    /*\r\n      Create a vault/purse that is just used once (purse)\r\n    */\r\n    for(@(_, *RevVault) <- revVaultCh; _ <- proceed1Ch) {\r\n      new unf, purseRevAddrCh, purseAuthKeyCh, purseVaultCh, deployerRevAddressCh, RevVaultCh, deployerVaultCh, deployerAuthKeyCh in {\r\n        revAddress!("fromUnforgeable", *unf, *purseRevAddrCh) |\r\n        RevVault!("unforgeableAuthKey", *unf, *purseAuthKeyCh) |\r\n        for (@purseAuthKey <- purseAuthKeyCh; @purseRevAddr <- purseRevAddrCh) {\r\n\r\n          RevVault!("findOrCreate", purseRevAddr, *purseVaultCh) |\r\n\r\n          for (\r\n            @(true, purseVault) <- purseVaultCh;\r\n            @publicKey <- publicKeyCh;\r\n            @purseId <- purseIdCh;\r\n            @merge <- mergeCh;\r\n            @contractId <- contractIdCh;\r\n            @price <- priceCh;\r\n            @quantity <- quantityCh;\r\n            @newId <- newIdCh;\r\n            @data <- dataCh\r\n          ) {\r\n\r\n            stdout!({\r\n              "publicKey": publicKey,\r\n              "price": price,\r\n              "merge": merge,\r\n              "quantity": quantity,\r\n              "purseId": purseId,\r\n              "contractId": contractId,\r\n              "newId": newId,\r\n            }) |\r\n            match {\r\n              "publicKey": publicKey,\r\n              "price": price,\r\n              "merge": merge,\r\n              "quantity": quantity,\r\n              "purseId": purseId,\r\n              "contractId": contractId,\r\n              "newId": newId,\r\n            } {\r\n              {\r\n                "publicKey": String,\r\n                "price": Int,\r\n                "merge": Bool,\r\n                "quantity": Int,\r\n                "purseId": String,\r\n                "contractId": String,\r\n                "newId": String,\r\n              } => {\r\n                proceed2Ch!(Nil)\r\n              }\r\n              _ => {\r\n                basket!({ "status": "failed", "message": "error: invalid payload, cancelled purchase and payment" }) |\r\n                stdout!(("failed", "error: invalid payload, cancelled purchase and payment"))\r\n              }\r\n            } |\r\n\r\n            for (_ <- proceed2Ch) {\r\n\r\n              revAddress!("fromPublicKey", publicKey.hexToBytes(), *deployerRevAddressCh) |\r\n              registryLookup!(\`rho:rchain:revVault\`, *RevVaultCh) |\r\n              for (@(_, RevVault) <- RevVaultCh; @deployerRevAddress <- deployerRevAddressCh) {\r\n                \r\n                // send price * quantity dust in purse\r\n                @RevVault!("findOrCreate", deployerRevAddress, *deployerVaultCh) |\r\n                @RevVault!("deployerAuthKey", *deployerId, *deployerAuthKeyCh) |\r\n                for (@(true, deployerVault) <- deployerVaultCh; @deployerAuthKey <- deployerAuthKeyCh) {\r\n\r\n                  stdout!(("Beginning transfer of ", price * quantity, "REV from", deployerRevAddress, "to", purseRevAddr)) |\r\n\r\n                  new resultCh, entryCh in {\r\n                    @deployerVault!("transfer", purseRevAddr, price * quantity, deployerAuthKey, *resultCh) |\r\n                    for (@result <- resultCh) {\r\n\r\n                      stdout!(("Finished transfer of ", price * quantity, "REV to", purseRevAddr, "result was:", result)) |\r\n                      match result {\r\n                        (true, Nil) => {\r\n                          boxCh!((\r\n                            "PURCHASE",\r\n                            {\r\n                              "contractId": contractId,\r\n                              "purseId": purseId,\r\n                              "data": data,\r\n                              "quantity": quantity,\r\n                              "merge": merge,\r\n                              "newId": newId,\r\n                              "purseRevAddr": purseRevAddr,\r\n                              "purseAuthKey": purseAuthKey\r\n                            },\r\n                            *returnCh\r\n                          )) |\r\n                          for (@r <- returnCh) {\r\n                            match r {\r\n                              String => {\r\n                                new refundPurseBalanceCh, refundResultCh in {\r\n                                  @purseVault!("balance", *refundPurseBalanceCh) |\r\n                                  for (@balance <- refundPurseBalanceCh) {\r\n                                    if (balance != price * quantity) {\r\n                                      stdout!("error: CRITICAL, purchase was not successful and balance of purse is now different from price * quantity")\r\n                                    } |\r\n                                    @purseVault!("transfer", deployerRevAddress, balance, purseAuthKey, *refundResultCh) |\r\n                                    for (@result <- refundResultCh)  {\r\n                                      match result {\r\n                                        (true, Nil) => {\r\n                                          match "error: purchase failed but was able to refund ${balance} " %% { "balance": balance } ++ r {\r\n                                            s => {\r\n                                              basket!({ "status": "failed", "message": s }) |\r\n                                              stdout!(s)\r\n                                            }\r\n                                          }\r\n                                        }\r\n                                        _ => {\r\n                                          stdout!(result) |\r\n                                          match "error: CRITICAL purchase failed and was NOT ABLE to refund ${balance} " %% { "balance": balance } ++ r {\r\n                                            s => {\r\n                                              basket!({ "status": "failed", "message": s }) |\r\n                                              stdout!(s)\r\n                                            }\r\n                                          }\r\n                                        }\r\n                                      }\r\n                                    }\r\n                                  }\r\n                                }\r\n                              }\r\n                              _ => {\r\n                                basket!({ "status": "completed" }) |\r\n                                stdout!("completed, purchase successful")\r\n                              }\r\n                            }\r\n                          }\r\n                        }\r\n                        _ => {\r\n                          basket!({ "status": "failed", "message": result }) |\r\n                          stdout!(("failed", result))\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}`,r.op_send_purse=({})=>'new basket,\r\n  sendReturnCh,\r\n  deletePurseReturnCh,\r\n  boxCh,\r\n  boxEntryCh,\r\n  boxEntry2Ch,\r\n  receivePursesReturnCh,\r\n  receivePursesReturn2Ch,\r\n  stdout(`rho:io:stdout`),\r\n  deployerId(`rho:rchain:deployerId`),\r\n  registryLookup(`rho:registry:lookup`)\r\nin {\r\n\r\n  @(*deployerId, "rho:id:FROM_BOX_REGISTRY_URI")!(({ "type": "READ_PURSES" }, *boxCh)) |\r\n\r\n  for (purses <- boxCh) {\r\n    match *purses.get(`rho:id:REGISTRY_URI`).get("PURSE_ID") {\r\n      Nil => {\r\n        basket!({ "status": "failed", "message": "purse not found" }) |\r\n        stdout!(("failed", "purse not found"))\r\n      }\r\n      purse => {\r\n        registryLookup!(`rho:id:TO_BOX_REGISTRY_URI`, *boxEntryCh) |\r\n        for (boxEntry <- boxEntryCh) {\r\n          boxEntry!(("PUBLIC_RECEIVE_PURSE", \r\n            {\r\n              "registryUri": `rho:id:REGISTRY_URI`,\r\n              "purse": purse,\r\n            },\r\n            *receivePursesReturnCh\r\n          )) |\r\n          for (r <- receivePursesReturnCh) {\r\n            match *r {\r\n              (true, Nil) => {\r\n                match "rho:id:TO_BOX_REGISTRY_URI" == "rho:id:FROM_BOX_REGISTRY_URI" {\r\n                  true => {\r\n                    stdout!("completed, purse sent") |\r\n                    basket!({ "status": "completed" })\r\n                  }\r\n                  false => {\r\n                    /*\r\n                      Remove the purse from emitter\'s box now that it is worthless :\r\n                      deleted in contract\r\n                    */\r\n                    @(*deployerId, "rho:id:FROM_BOX_REGISTRY_URI")!((\r\n                      { "type": "DELETE_PURSE", "payload": { "registryUri": `rho:id:REGISTRY_URI`, "id": "PURSE_ID" } },\r\n                      *deletePurseReturnCh\r\n                    )) |\r\n                    for (r2 <- deletePurseReturnCh) {\r\n                      match *r2 {\r\n                        String => {\r\n                          stdout!("WARNING completed, purse sent but could not remove from box") |\r\n                          basket!({ "status": "completed" })\r\n                        }\r\n                        _ => {\r\n                          stdout!("completed, purse sent and removed from box") |\r\n                          basket!({ "status": "completed" })\r\n                        }\r\n                      }\r\n                    }\r\n\r\n                  }\r\n                }\r\n              }\r\n              _ => {\r\n                registryLookup!(`rho:id:FROM_BOX_REGISTRY_URI`, *boxEntry2Ch) |\r\n                for (boxEntry2 <- boxEntry2Ch) {\r\n                  boxEntry!(("PUBLIC_RECEIVE_PURSE", \r\n                    {\r\n                      "registryUri": `rho:id:REGISTRY_URI`,\r\n                      "purse": purse,\r\n                    },\r\n                    *receivePursesReturn2Ch\r\n                  ))\r\n                } |\r\n                for (r2 <- receivePursesReturn2Ch) {\r\n                  match *r2 {\r\n                    String => {\r\n                      stdout!("Failed to send, could not send back to emitter box, purse may be lost " ++ *r2 ++ *r) |\r\n                      basket!({ "status": "failed", "message": "Failed to send, could not send back to emitter box, purse may be lost " ++ *r2 ++ *r})\r\n                    }\r\n                    _ => {\r\n                      stdout!("Failed to send, could send back to emitter box" ++ *r2) |\r\n                      basket!({ "status": "failed", "message": "Failed to send, could send back to emitter box" ++ *r2 })\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n',r.op_test=({composeEntryUri:r})=>`\r\nnew\r\n  return(\`rho:rchain:deployId\`),\r\n  basket,\r\n  revVaultCh,\r\n  boxCh,\r\n\r\n  returnCh,\r\n  quantityCh,\r\n  mergeCh,\r\n  publicKeyCh,\r\n  priceCh,\r\n  newIdCh,\r\n  dataCh,\r\n  purseIdCh,\r\n  contractIdCh,\r\n\r\n  revAddressCh,\r\n  contractExistsCh,\r\n  proceed1Ch,\r\n  proceed2Ch,\r\n  registryLookup(\`rho:registry:lookup\`),\r\n  deployerId(\`rho:rchain:deployerId\`),\r\n\r\n  revAddress(\`rho:rev:address\`)\r\n  \r\nin {\r\n  registryLookup!(\`${r}\`, *contractExistsCh) |\r\n  \r\n  return!("testa") |\r\n  for (_ <- contractExistsCh) {\r\n    return!("test")\r\n  } \r\n\r\n   \r\n}`,r.op_update_purse_data=({})=>'new basket,\r\n  returnCh,\r\n  boxCh,\r\n  stdout(`rho:io:stdout`),\r\n  deployerId(`rho:rchain:deployerId`),\r\n  registryLookup(`rho:registry:lookup`)\r\nin {\r\n\r\n  for (boxCh <<- @(*deployerId, "rchain-token-box", "MASTER_REGISTRY_URI", "BOX_ID")) {\r\n    boxCh!(("UPDATE_PURSE_DATA", { "contractId": "CONTRACT_ID", "data": "UPDATE_PURSE_DATAA", "purseId": "PURSE_ID" }, *returnCh)) |\r\n    for (@r <- returnCh) {\r\n      match r {\r\n        String => {\r\n          basket!({ "status": "failed", "message": r }) |\r\n          stdout!(("failed", r))\r\n        }\r\n        _ => {\r\n          basket!({ "status": "completed" }) |\r\n          stdout!("completed, data updated")\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n',r.op_update_purse_price=({})=>'new basket,\r\n  returnCh,\r\n  boxCh,\r\n  stdout(`rho:io:stdout`),\r\n  deployerId(`rho:rchain:deployerId`),\r\n  registryLookup(`rho:registry:lookup`)\r\nin {\r\n\r\n  for (boxCh <<- @(*deployerId, "rchain-token-box", "MASTER_REGISTRY_URI", "BOX_ID")) {\r\n    boxCh!(("UPDATE_PURSE_PRICE", { "contractId": "CONTRACT_ID", "price": PRICEE, "purseId": "PURSE_ID" }, *returnCh)) |\r\n    for (@r <- returnCh) {\r\n      match r {\r\n        String => {\r\n          basket!({ "status": "failed", "message": r }) |\r\n          stdout!(("failed", r))\r\n        }\r\n        _ => {\r\n          basket!({ "status": "completed" }) |\r\n          stdout!("completed, price updated")\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n',r.op_withdraw=({})=>'new basket,\r\n  withdrawReturnCh,\r\n  boxCh,\r\n  stdout(`rho:io:stdout`),\r\n  deployerId(`rho:rchain:deployerId`),\r\n  registryLookup(`rho:registry:lookup`)\r\nin {\r\n\r\n  for (boxCh <<- @(*deployerId, "rchain-token-box", "MASTER_REGISTRY_URI", "BOX_ID")) {\r\n    boxCh!(("WITHDRAW", { "contractId": "CONTRACT_ID", "quantity": WITHDRAW_QUANTITY, "toBoxId": "TO_BOX_ID", "purseId": "PURSE_ID", "merge": MERGE }, *withdrawReturnCh)) |\r\n    for (@r <- withdrawReturnCh) {\r\n      match r {\r\n        String => {\r\n          basket!({ "status": "failed", "message": r }) |\r\n          stdout!(("failed", r))\r\n        }\r\n        _ => {\r\n          basket!({ "status": "completed" }) |\r\n          stdout!("completed, withdraw successful")\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n',r.read_all_purses=({})=>'new return, entryCh, readCh, lookup(`rho:registry:lookup`) in {\r\n  lookup!(`rho:id:MASTER_REGISTRY_URI`, *entryCh) |\r\n  for(entry <- entryCh) {\r\n    new x in {\r\n      entry!(("PUBLIC_READ_ALL_PURSES", "CONTRACT_ID", *x)) |\r\n      for (y <- x) {\r\n        return!(*y)\r\n      }\r\n    }\r\n  }\r\n}',r.read_box=({})=>'new return, entryCh, lookup(`rho:registry:lookup`), stdout(`rho:io:stdout`) in {\r\n  lookup!(`rho:id:MASTER_REGISTRY_URI`, *entryCh) |\r\n  for(entry <- entryCh) {\r\n    new a in {\r\n      entry!(("PUBLIC_READ_BOX", "BOX_ID", *a)) |\r\n      for (@box <- a) {\r\n        return!(box)\r\n      }\r\n    }\r\n  }\r\n}',r.read_config=({})=>'new return, entryCh, readCh, lookup(`rho:registry:lookup`) in {\r\n  lookup!(`rho:id:MASTER_REGISTRY_URI`, *entryCh) |\r\n  for(entry <- entryCh) {\r\n    new x in {\r\n      entry!(("PUBLIC_READ_CONFIG", "CONTRACT_ID", *x)) |\r\n      for (y <- x) {\r\n        return!(*y)\r\n      }\r\n    }\r\n  }\r\n}',r.read_purses=({})=>'new return, entryCh, readCh, lookup(`rho:registry:lookup`) in {\r\n  \r\n  lookup!(`rho:arg1:entryUri`, *entryCh) |  lookup!(`rho:arg2:entryUri2`, *entryCh) |\r\n  for(entry <- entryCh) {\r\n    new x in {\r\n      entry!(("PUBLIC_READ_PURSES", { "contractId": "CONTRACT_ID", "purseIds": Set(PURSES_IDS) }, *x)) |\r\n      for (y <- x) {\r\n        return!(*y)\r\n      }\r\n    }\r\n  }\r\n}',r.read_purses_data=({})=>'new return, entryCh, readCh, lookup(`rho:registry:lookup`) in {\r\n  lookup!(`rho:id:MASTER_REGISTRY_URI`, *entryCh) |\r\n  for(entry <- entryCh) {\r\n    new x in {\r\n      entry!(("PUBLIC_READ_PURSES_DATA", { "contractId": "CONTRACT_ID", "purseIds": Set(PURSES_IDS) }, *x)) |\r\n      for (y <- x) {\r\n        return!(*y)\r\n      }\r\n    }\r\n  }\r\n}',r.store=({depth:r})=>` \r\n new \r\n  basket,\r\n\r\n  entryCh,\r\n  entryUriCh,\r\n\r\n  byteArraySafeToStoreCh,\r\n  iterateOnThmKeysCh,\r\n  createPursesCh,\r\n  makePurseCh,\r\n  calculateFeeCh,\r\n  pursesTreeHashMapCh,\r\n  pursesForSaleTreeHashMapCh,\r\n  initializeOCAPOnBoxCh,\r\n\r\n    // dont use multi line /* */ -> error\r\n    // 'vault is the ultimate accessibility unforgeable in\r\n    // master contract, every data is stored in channels that\r\n    // derives from *vault unforgeable name\r\n\r\n    // // tree hash map of purses :\r\n    // thm <- @(*vault, "purses", "contract03")\r\n\r\n    // // tree hash map of purses data :\r\n    // thm <- @(*vault, "pursesData", "contract03")\r\n\r\n    // // contract's configs\r\n    // config <- @(*vault, "contractConfig", "contract03")\r\n\r\n    // // boxes\r\n    // box <- @(*vault, "boxes", "box01")\r\n    \r\n    // // box's configs\r\n    // config <- @(*vault, "boxConfig", "box01")\r\n\r\n    // // super keys of a given box\r\n    // superKeys <- @(*vault, "boxesSuperKeys", "box01")'\r\n\r\n  vault,\r\n\r\n  \r\n    // boxesThm and contractsThm only store the list\r\n    // of existing contracts / boxes, ex:\r\n    // boxesThm:\r\n    // { "box1": "exists", "mycoolbox": "exists" }\r\n\r\n    // Then each box is a Map stored at a unique channel\r\n    // (see above) and has the following structure:\r\n    // {\r\n    //   [contractId: string]: Set(purseId: string)\r\n    // }\r\n\r\n    // Each contract has its own tree hash map, and\r\n    // have the following structure:\r\n    // pursesThm:\r\n    // {\r\n    //   "1": { quantity: 2, type: "0", box: "box1", price: Nil},\r\n    //   "2": { quantity: 12, type: "0", box: "box1", price: 2},\r\n    // }\r\n  \r\n  boxesReadyCh,\r\n  contractsReadyCh,\r\n\r\n  TreeHashMap,\r\n\r\n  savePurseInBoxCh,\r\n  removePurseInBoxCh,\r\n  getBoxCh,\r\n  getPurseCh,\r\n  getContractPursesThmCh,\r\n  getContractPursesDataThmCh,\r\n\r\n  insertArbitrary(\`rho:registry:insertArbitrary\`),\r\n  revAddress(\`rho:rev:address\`),\r\n  registryLookup(\`rho:registry:lookup\`),\r\n  stdout(\`rho:rchain:deployId\`)\r\n\r\nin {\r\n\r\n /*##########################################################################################*/\r\n  /*                             TreeHashMap (reimplementation)                               */\r\n  // Communications between channels have generally been reduced to reduce amount of\r\n  // serialization / deserialization\r\n\r\n  // when you "init" you can choose that the processes are also stored as bytes, instead of storing a map for each node, it stores a map at channel @map, and bytes at channel @(map, "bytes), this will make the "getAllValues" 10x, 20x, 30x faster depending on the process you are storing\r\n\r\n  // !!! make sure your processes do not contain the string "£$£$", or the bytes c2a324c2a324, those are used as delimiters\r\n\r\n  // depth 1 = 12 maps in tree hash map\r\n  // depth 2 = 12 * 12 = 144 maps in tree hash map\r\n  // etc...\r\n\r\n  TreeHashMap!("init", "${r}", true, *boxesReadyCh) |\r\n  TreeHashMap!("init", "${r}", false, *contractsReadyCh) |\r\n\r\n  new MakeNode, ByteArrayToNybbleList, TreeHashMapSetter, TreeHashMapGetter, HowManyPrefixes, NybbleListForI, RemoveBytesSectionIfExistsCh, keccak256Hash(\`rho:crypto:keccak256Hash\`), powersCh, storeToken, nodeGet in {\r\n    match ([1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,655256], ["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"], 12) {\r\n      (powers, hexas, base) => {\r\n        contract MakeNode(@initVal, @node) = {\r\n          @[node, *storeToken]!(initVal)\r\n        } |\r\n\r\n        contract nodeGet(@node, ret) = {\r\n          for (@val <<- @[node, *storeToken]) {\r\n            ret!(val)\r\n          }\r\n        } |\r\n\r\n        contract HowManyPrefixes(@map, ret) = {\r\n          for (@depth <<- @(map, "depth")) {\r\n            match depth {\r\n              1 => ret!(base)\r\n              2 => ret!(base * base)\r\n              3 => ret!(base * base * base)\r\n              4 => ret!(base * base * base * base)\r\n            }\r\n          }\r\n        } |\r\n\r\n        contract NybbleListForI(@map, @i, @depth, ret) = {\r\n          match depth {\r\n            1 => {\r\n              match hexas.nth(i % base) {\r\n                str => {\r\n                  ByteArrayToNybbleList!(str.hexToBytes(), 0, depth, [], *ret)\r\n                }\r\n              }\r\n            }\r\n            2 => {\r\n              match hexas.nth(i / base) ++ hexas.nth(i % base) {\r\n                str => {\r\n                  ByteArrayToNybbleList!(str.hexToBytes(), 0, depth, [], *ret)\r\n                }\r\n              }\r\n            }\r\n            3 => {\r\n              match hexas.nth(i / base / base) ++ hexas.nth(i / base) ++ hexas.nth(i % base) {\r\n                str => {\r\n                  ByteArrayToNybbleList!(str.hexToBytes(), 0, depth, [], *ret)\r\n                }\r\n              }\r\n            }\r\n            4 => {\r\n              match hexas.nth(i / base / base / base) ++ hexas.nth(i / base / base) ++ hexas.nth(i / base) ++ hexas.nth(i % base) {\r\n                str => {\r\n                  ByteArrayToNybbleList!(str.hexToBytes(), 0, depth, [], *ret)\r\n                }\r\n              }\r\n            }\r\n          }\r\n        } |\r\n\r\n        contract ByteArrayToNybbleList(@ba, @n, @len, @acc, ret) = {\r\n          if (n == len) {\r\n            ret!(acc)\r\n          } else {\r\n            ByteArrayToNybbleList!(ba, n+1, len, acc ++ [ ba.nth(n) % base ], *ret)\r\n          }\r\n        } |\r\n\r\n        contract TreeHashMap(@"init", @depth, @alsoStoreAsBytes, ret) = {\r\n          new map in {\r\n            MakeNode!(0, (*map, [])) |\r\n            if (alsoStoreAsBytes == true) {\r\n              MakeNode!(0, ((*map, "bytes"), []))\r\n            } |\r\n            @(*map, "depth")!!(depth) |\r\n            @(*map, "alsoStoreAsBytes")!!(alsoStoreAsBytes) |\r\n            ret!(*map)\r\n          }\r\n        } |\r\n\r\n        contract TreeHashMapGetter(@map, @nybList, @n, @len, @suffix, ret) = {\r\n          // Look up the value of the node at (map, nybList.slice(0, n + 1))\r\n          for (@val <<- @[(map, nybList.slice(0, n)), *storeToken]) {\r\n            if (n == len) {\r\n              ret!(val.get(suffix))\r\n            } else {\r\n              // Otherwise check if the rest of the path exists.\r\n              // Bit k set means node k exists.\r\n              // nybList.nth(n) is the node number\r\n              // val & powers.nth(nybList.nth(n)) is nonzero if the node exists\r\n              // (val / powers.nth(nybList.nth(n))) % 2 is 1 if the node exists\r\n              if ((val / powers.nth(nybList.nth(n))) % 2 == 0) {\r\n                ret!(Nil)\r\n              } else {\r\n                TreeHashMapGetter!(map, nybList, n + 1, len, suffix, *ret)\r\n              }\r\n            }\r\n          }\r\n        } |\r\n\r\n        contract TreeHashMap(@"get", @map, @key, ret) = {\r\n          new hashCh, nybListCh in {\r\n            // Hash the key to get a 256-bit array\r\n            keccak256Hash!(key.toByteArray(), *hashCh) |\r\n            for (@hash <- hashCh) {\r\n              for (@depth <<- @(map, "depth")) {\r\n                // Get the bit list\r\n                ByteArrayToNybbleList!(hash, 0, depth, [], *nybListCh) |\r\n                for (@nybList <- nybListCh) {\r\n                  TreeHashMapGetter!(map, nybList, 0,  depth, hash.slice(depth, 32), *ret)\r\n                }\r\n              }\r\n            }\r\n          }\r\n        } |\r\n    \r\n        contract TreeHashMap(@"getAllValues", @map, ret) = {\r\n          new hashCh, resultCh, howManyPrefixesCh, iterateOnPrefixesCh, nybListCh in {\r\n            HowManyPrefixes!(map, *howManyPrefixesCh) |\r\n            for (@depth <<- @(map, "depth")) {\r\n              for (@alsoStoreAsBytes <<- @(map, "alsoStoreAsBytes")) {\r\n                for (@howManyPrefixes <- howManyPrefixesCh ) {\r\n                  contract iterateOnPrefixesCh() = {\r\n                    new itCh, bytesOrMapCh, TreeHashMapGetterValues in {\r\n                      // do not move it up, the goal is reduce the number of serializatin / dezerialization\r\n                      contract TreeHashMapGetterValues(@channel, @nybList, @n, @len, @i) = {\r\n                        // channel is either map or (map, "bytes")\r\n                        // Look up the value of the node at (channel, nybList.slice(0, n + 1))\r\n                        for (@val <<- @[(channel, nybList.slice(0, n)), *storeToken]) {\r\n                          if (n == len) {\r\n                            if (val == Nil) {\r\n                              itCh!(i + 1)\r\n                            } else {\r\n                              if (alsoStoreAsBytes == true) {\r\n                                for (@bytes <- bytesOrMapCh) {\r\n                                  itCh!(i + 1) |\r\n                                  // store-as-bytes-map\r\n                                  bytesOrMapCh!(bytes.union(val))\r\n                                  // store-as-bytes-array\r\n                                //   if (bytes == Nil) {\r\n                                //     bytesOrMapCh!(bytes)\r\n                                //   } else {\r\n                                //     bytesOrMapCh!(bytes ++ val)\r\n                                //   }\r\n                                }\r\n                              } else {\r\n                                for (@map <- bytesOrMapCh) {\r\n                                  bytesOrMapCh!(map.union(val)) |\r\n                                  itCh!(i + 1)\r\n                                }\r\n                              }\r\n                            }\r\n                          } else {\r\n                            // Otherwise check if the rest of the path exists.\r\n                            // Bit k set means node k exists.\r\n                            // nybList.nth(n) is the node number\r\n                            // val & powers.nth(nybList.nth(n)) is nonzero if the node exists\r\n                            // (val / powers.nth(nybList.nth(n))) % 2 is 1 if the node exists\r\n                            if ((val / powers.nth(nybList.nth(n))) % 2 == 0) {\r\n                              itCh!(i + 1)\r\n                            } else {\r\n                              TreeHashMapGetterValues!(channel, nybList, n + 1, len, i)\r\n                            }\r\n                          }\r\n                        }\r\n                      } |\r\n\r\n                      for (@i <= itCh) {\r\n                        match i <= howManyPrefixes - 1 {\r\n                          false => {\r\n                            for (@a <- bytesOrMapCh) {\r\n                              ret!(a)\r\n                            }\r\n                          }\r\n                          true => {\r\n                            NybbleListForI!(map, i, depth, *nybListCh) |\r\n                            for (@nybList <- nybListCh) {\r\n                              if (alsoStoreAsBytes == true) {\r\n                                TreeHashMapGetterValues!((map, "bytes"), nybList, 0, depth, i)\r\n                              } else {\r\n                                TreeHashMapGetterValues!(map, nybList, 0, depth, i)\r\n                              }\r\n                            }\r\n                          }\r\n                        }\r\n                      } |\r\n                      if (alsoStoreAsBytes == true) {\r\n                        // store-as-bytes-map\r\n                        bytesOrMapCh!({})\r\n                        // store-as-bytes-array\r\n                        /* bytesOrMapCh!(Nil) */\r\n                      } else {\r\n                        bytesOrMapCh!({})\r\n                      } |\r\n                      itCh!(0)\r\n                    }\r\n                  } |\r\n\r\n                  iterateOnPrefixesCh!()\r\n                }\r\n              }\r\n            }\r\n          }\r\n        } |\r\n\r\n        contract TreeHashMapSetter(@channel, @nybList, @n, @len, @newVal, @suffix, ret) = {\r\n          // channel is either map or (map, "bytes")\r\n          // Look up the value of the node at (channel, nybList.slice(0, n + 1))\r\n          new valCh, restCh in {\r\n            match (channel, nybList.slice(0, n)) {\r\n              node => {\r\n                for (@val <<- @[node, *storeToken]) {\r\n                  if (n == len) {\r\n                    // Acquire the lock on this node\r\n                    for (@val <- @[node, *storeToken]) {\r\n                      // If we're at the end of the path, set the node to newVal.\r\n                      if (val == 0) {\r\n                        // Release the lock\r\n                        @[node, *storeToken]!({suffix: newVal}) |\r\n                        // Return\r\n                        ret!(Nil)\r\n                      }\r\n                      else {\r\n                        // Release the lock\r\n                        if (newVal == Nil) {\r\n                          @[node, *storeToken]!(val.delete(suffix)) |\r\n                          // Return\r\n                          ret!(Nil)\r\n                        } else {\r\n                          @[node, *storeToken]!(val.set(suffix, newVal)) |\r\n                          // Return\r\n                          ret!(Nil)\r\n                        }\r\n                      }\r\n                    }\r\n                  } else {\r\n                    // Otherwise make the rest of the path exist.\r\n                    // Bit k set means child node k exists.\r\n                    if ((val/powers.nth(nybList.nth(n))) % 2 == 0) {\r\n                      // Child node missing\r\n                      // Acquire the lock\r\n                      for (@val <- @[node, *storeToken]) {\r\n                        // Re-test value\r\n                        if ((val/powers.nth(nybList.nth(n))) % 2 == 0) {\r\n                          // Child node still missing\r\n                          // Create node, set node to 0\r\n                          MakeNode!(0, (channel, nybList.slice(0, n + 1))) |\r\n                          // Update current node to val | (1 << nybList.nth(n))\r\n                          match nybList.nth(n) {\r\n                            bit => {\r\n                              // val | (1 << bit)\r\n                              // Bitwise operators would be really nice to have!\r\n                              // Release the lock\r\n                              @[node, *storeToken]!((val % powers.nth(bit)) +\r\n                                (val / powers.nth(bit + 1)) * powers.nth(bit + 1) +\r\n                                powers.nth(bit))\r\n                            }\r\n                          } |\r\n                          // Child node now exists, loop\r\n                          TreeHashMapSetter!(channel, nybList, n + 1, len, newVal, suffix, *ret)\r\n                        } else {\r\n                          // Child node created between reads\r\n                          // Release lock\r\n                          @[node, *storeToken]!(val) |\r\n                          // Loop\r\n                          TreeHashMapSetter!(channel, nybList, n + 1, len, newVal, suffix, *ret)\r\n                        }\r\n                      }\r\n                    } else {\r\n                      // Child node exists, loop\r\n                      TreeHashMapSetter!(channel, nybList, n + 1, len, newVal, suffix, *ret)\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        } |\r\n\r\n        contract TreeHashMap(@"set", @map, @key, @newVal, ret) = {\r\n          new hashCh, nybListCh in {\r\n            // Hash the key to get a 256-bit array\r\n            keccak256Hash!(key.toByteArray(), *hashCh) |\r\n            for (@hash <- hashCh) {\r\n              for (@depth <<- @(map, "depth")) {\r\n                for (@alsoStoreAsBytes <<- @(map, "alsoStoreAsBytes")) {\r\n                  ByteArrayToNybbleList!(hash, 0, depth, [], *nybListCh) |\r\n                  // Get the bit list\r\n                  for (@nybList <- nybListCh) {\r\n                    if (alsoStoreAsBytes == true) {\r\n                      new ret1, ret2 in {\r\n                        if (newVal == Nil) {\r\n                          TreeHashMapSetter!((map, "bytes"), nybList, 0,  depth, Nil, hash.slice(depth, 32), *ret2)\r\n                        } else {\r\n                          TreeHashMapSetter!((map, "bytes"), nybList, 0,  depth, newVal.toByteArray(), hash.slice(depth, 32), *ret2)\r\n                        } |\r\n                        TreeHashMapSetter!(map, nybList, 0, depth, newVal, hash.slice(depth, 32), *ret1) |\r\n                        for (_ <- ret1; _ <- ret2) {\r\n                          ret!(Nil)\r\n                        }\r\n                      }\r\n                    } else {\r\n                      TreeHashMapSetter!(map, nybList, 0,  depth, newVal, hash.slice(depth, 32), *ret)\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  } \r\n}`,r.test=5,Object.defineProperty(r,"__esModule",{value:!0}),r[Symbol.toStringTag]="Module"}));
